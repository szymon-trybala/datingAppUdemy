.net core sdk (cli, to z vs2019 to co innego)
node.js najnowsze lts, npm ważny
vscode
db browser for sqlite 
postman

baza danych -> orm (object relation mapping, obiekty c# tworzące się na podstawie danych z bazy) -> api (umożliwia dogadanie sie 
orm ze spa) -> spa(angular) -> przeglądarka

najprostsze możliwe przekazanie danych z bazy do przeglararki, potem stopniowa rozbudowa

typ projektu .net core - asp net core web api żeby 3 warstwy były maksymalnie niezależne
dodać -o lokalizacja -n nazwa

Rozszerzenia do vscode:
c# od ms
c# extensions do szybkiego tworzenia klas 
nuget package manager

Projekt c# - Program.cs = main i CreateWebHostServer (tworzy Kestrel web server)
	Startup.cs = konfiguracja web servera - env (developer environment czy PRODUKCJA, to drugie daje hsts czyli powiazanie z https)
	PÓKI CO zakomentować to z https, do tego dodaje do web servera mvc framework który przekierowuje requesty do odpowiedniego
	kontrolera
	value controller - przekierowanie do odpowiedniego kontrolera odbywa sie przez 

	ctrl + slash = komentowanie linii

	Dotarcie do strony którą obsługuje ten kontroler:  http://localhost:5000/api/values
    	localhost bo serwer jest tam gdzie klient, 5000 bo to port kestrela, api bo route linijka nizej, values bo bierze 
        pod uwage slowo przed slowem "controller"

	bloki z httpGet, HttpPut, HttpPost uruchamiają ten blok dla konkretnych requestów http o tych nazwach.

launchSettings.json - konfiguracja serwera kestrel, ustalanie portow itd
Ctrl+tylda = terminal, dotnet run
Domyślnie nie będzie działać bo trzeba otworzyć /api/values żeby serwer przetworzył jakieś żądanie

Konfiguracja typu debugowania itd - appsetings.json, appsetingsDevelopment.json
Zmiana trybu: launchSettings.json - ASPNETCORE_ENVIRONMENT
dotnet watch run - uruchamia serwer i restartuje go przy zmianach kodu

Tworzenie modelu, czyli klasy która przechowuje dane z bazy (Value.cs) - na początku bardzo prosty
prop + tab = autogenerowanie klasy
Entity Framework = łączenie modelu (entity, w tym wypadku klasa Value) z bazą - stworzenie klasy (DataContext.cs)
która to zrobi - nowa klasa dziedziczy po klasie DbContext
Ctrl+kropka = autosugestie!
ctor + tab = autogenerowanie konstruktora
Konstruktor musi mieć jako argument klasę DbContextOptions<DataContext> : base (options)
DataContext powinno zawierać klase DbSet<Value> która przetwarza zapytania linq na zapytania do bazy i tworzy bazę. 
Value to wcześniej utworzony model (entity). Nazwa obiektu to nazwa tabeli w bazie

Poinformowanie api o nowej bazie i klasie value - w Startup.cs w metodzie ConfigureServices dodajemy service adddbcontext,
w <> dodajemy nazwę klasy datacontext i przekazujemy w opcjach przez wyr lambda typ bazy, tutaj sqlite
Zainstalować sqlite - jeśli jest addon nuget - ctrl+shift+p, -> nuget add package -> Microsoft.EntityFrameworkCore.Sqlite
Connection string dodaje się w appsetings.json - dzięki temu można go wywołać w dowolnym miejscu i zawsze bedzie dostepny, nawet w 
developement mode, bo json developementa nadpisuje zwykly, jesli w zwyklym bedzie rzecz ktorej nie ma w develoepement to jej nie nadpisze
 "ConnectionStrings": {
    "DefaultConnection": "Data Source=DatingApp.db"
  },
wewnatrz 1 nawiasu wasatego w appsettings.json
dostanie sie do tego z c#: Startup.cs - Configuration.GetConnectionString("DefaultConnection") - znajduje sekcje o nazwie DefaultConnection

Tworzenie bazy: dotnet ef migrations add InitialCreate - to sprawdzi nasze dbcontext (które zawierają info o values), sprawdzi gdzie
chcemy zapisać bazę (Startup.cs - AddDbContext), wykryje które pole klasy to Id i da je jako primary key itd.
Migration tworzy PLAN przetworzenia danych z kodu do prawdziwej bazy danych
dotnet ef database update - aktualizuje plik z danych migracji (albo go tworzy jesli go nie ma)
Otworzyc baze przez Db Browser for SQLite i dodac kilka rekordow

ctrl+p = go to file
Powiązanie bazy z metodą httpget - wstrzyknięcie datacontext do metody przez utworzenie w klasie valuescontroller i prywatne pole
z DataContext
Potem w httpget zmiana na IActionResult i wewnątrz stworzenie zmiennej do której wrzuca się _context.Values.ToList() (DataContext
zawiera wszystkie potrzebne metody). Potem zwrócić klientowi wewnatrz response Ok (czyli Ok(values))
HttpGet("{id}") podobnie, tylko w metodzie GetValue przekazac int id, a potem zeby sprwadzic ktora to zmienna uzyc wyrazenia lambda
var value = _context.Values.FirstOrDefault(x => x.Id == id);

Otworzyc postmana, sprawdzic czy wszystko jest ok "http://localhost:5000/api/values", można dodać potem "/3" itd, jesli przekroczymy
ilosc rekordow w bazie to zwroci pusta strone i status 204 no context bo uzylismy metody FirstOrDefault zeby nie wywaliło wyjątku

Http requesty asynchronicznie: zmienic metode ktora uruchamia request na async Task<IActionResult>. Teraz metoda bedzie zwracac 
asynchroniczne zadanie. Przy miejscu które może trwać dużo czasu i chcemy żeby nie blokowało całego programu dodajemy await,
dodatkowo trzeba zmienic metode przy await na asynchroniczna (ToListAsync). Każdy request powinien być async

Zainstalować angular cli przez npm, użyłem wersji 6.2.9 lts, stworzyć projekt przez ng new DatingApp-SPA

Użyte moduły i ich wersje są opisane w package.json, główny folder aplikacji Angulara to src/app. Angular ma komponenty, czyli coś
w rodzaju klas z powiązaniami. Domyślnie w pliku index.html uruchamiany jest komponent z selectorem "app-root", czyli ten w 
domyślnym pliku app.component.ts. app.module.ts to plik z modułem, czyli czymś co ładuje poszczególne komponenty.
Moduł jest ładowany bezpośrednio w pliku main.ts. w nim jeszcze jest info że aplikacja jest pod przeglądarkę (platformBrowserDynamic)
i że chcemy uzywac bootstrapa w module (bootstrapModule(AppModule)), co włacza tez bootstrapa na każdy komponent uruchamiany przez moduł
main.ts jest uruchamiany mimo że w index.html nie ma zadnej informacji o nim dzieki webpackowi w angularze, ktory pakuje wszystko do js
i wstrzykuje do htmla w trakcie kompilacji (?).
Uruchomic projekt angulara (ng serve), bedzie sluchac na porcie 4200

Dodac kilka rozszerzen do vscode dla angulara: Angular v7 Snippets, Angular Files do szybkiego tworzenia plkikow, ANgular Language 
Service (goto definition), Angular2-switcher do szybkiego przełączania pomiedzy plikami ts, html i css, auto rename tag, bracket pair
colorizer, debugger for chrome, path intellisense, prettier do autoformatu, tslint do podkreślania.

Tworzenie http requestów w angularze: stworzyć komponent (ppm i create component, value wtedy zrobi folder z wszystkimi potrzebnymi
plikami). Dodało też w pliku app.module informacje że korzystamy z komponentu value. 
Klasy do requestów są w pliku angular/common/http, trzeba zaimportować je w app.module.ts. Potem w value.component.ts 
tworzymy pole values:any, które będą przechowywać dane z serwera aspnet i metodę getValues, która korzysta z httpclienta angulara
i robi request na localhost:500/api/values, a potem subskrybuje, czyli zapisuje odpowiedź do values: 
getValues() {
    this.http.get('http://localhost:5000/api/values').subscribe(response => {
      this.values = response;
    }, error => {
      console.log(error);
    });
Dodać jeszcze wywołanie metody getValues w ngOnInit, czyli metodzie wywołującej się po załadowaniu komponentu
Alt+O = przejście do http danego komponentu, Alt+U = przejście do ts danego komponentu
W stronie tytułowej angulara (app.component.html) dodać znacznik <app-value>, który uruchomi komponent value (nie będzie go widać na stronie
bo nie ma backendu, ale można go zobaczyć w konsoli). W konsoli jest info o Access-Control-Allow-Origin blocked blabla, trzeba to poprawic i dodac cors

CORS pozwala na ustalenie którzy klienci mogą mieć dostęp do naszego api (np wywołanie localhost:5000 z localhost:4200). Zeby to zrobic
najpierw w metodzie configureServies trzeba dodać Cors (services.AddCors()), a potem go ustalić na co ma pozwalać (w metodzie configure
dodać app.UseCors(x => x.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());, to pozwala na wszystko wszystkim, później to się zmieni

Wyświetlenie wartości na stronie, a nie w konsoli chroma: w value.component.html przy znaczniku p dodać pętlę angulara która pozwala na wrzucanie elementow na strone:
<p *ngFor="let value of values">
  {{value.id}}, {{value.name}}
</p>
values to var do którego przesyłane są dane z api, mozna sie dostac do poszczegolnych id i name, sukces XD

Bootstrap i FontAwesome: npm install bootstrap font-awesome
potem w głównym pliku css zaimportować bootstrap.min.css a potem font-awesome.min.css, potem w htmlu componenta można usunąć znacznik style

git: wywalic .git z spa, dodac gitignore dla api, zrobic git init w głównym folerze aplikacji, stworzyć repo na githubie, zrobić remote
add origin [adres], potem pierwszy commit i push to 

dodanie modelu usera: stworzyc klase z id, loginem, hashem hasla i solą (oba to byte[]), dodac info o tej klasie w datacontext, zrobic kolejna
migracje, potem dac dotnet ef database update

Repository interface - kolejna warstwa abstrakcji ktora jest interfejsem. Zawiera szkielet wszystkich metod ktore beda potrzebne api do 
wykonania jego metod, i kazda klasa ktora bedzie pobierac dane z bazy musi implementowac ten interfejs, dzieki czemu api bedzie po czesci 
niezalezne od frameworków.

Stworzenie interfejsu: w folderze data stworzyc interfejs IAuthRepository, zrobic 3 taski (metody async), login ktory przyjmuje nazwe usera, 
haslo a zwraca obiekt user (w jaki sposob ten user zostanie stworzony to juz kwestia konkretnego AuthRepository), register który zwraca usera
i przyjmuje usera i password, i UserExists ktory przyjmuje string username a zwraca boola. 

Rejestracja - najpierw tworzymy klase AuthRepository ktora implementuje interfejs IAuthRepository, w konstruktorze będzie DataContext dzięki
któremu bedzie mozna przesylac dane do bazy przez ef, potem tworzymy tymczasowe zmienne dla hashu i soli danego usera, potem funkcję do generowania 
hasha ktora przyjmuje haslo podane w metodzie Register i tymczasowe zmienne hashu i soli jako referencje (out). Ta funkcja implementuje 
interfejs IDisposable, czyli po jej wykonaniu wszystko zostaje wrzucone do garbage collectora, wiec trzeba stworzyc blok 
using(var hmac = new HMACSHA512). w nim wyciagamy  hmac.Key (czyli sol wygenerowana przy stworzeniu obiektu hmac) jako passwordSalt, i 
uzywamy metody ComputeHash z haslem usera jako argumentem i wrzucamy do passwordHash. Potem powrot do metody Register, 
tam przypisujemy naszemu userowi sol i haslo = temp soli i hasle, potem uzywamy  naszego _context.Users.AddAsync(user) 
i _context.SaveChangesAsync(), zwracamy usera.

Logowanie - podobnie, stworzyc zmienna przechowujaca usera (var user = await _context.Users.FirstOrDefaultAsync(x => x.Username == username);) ktora
wyszukuje go w bazie, potem sprawdzic czy znalazlo, potem uruchomic i stworzyc metode ktora w podobny sposob co wyzej sprawdza czy hash sie zgadza 
przy konstruktorze hmac wrzucic sol z obiektu user, potem jesli sprawdzanie == false zwrocic nulla, jesli true zwrocic usera

Dodawanie authrepo do konfiguracji api - w funkcji ConfigureServices.AddScoped<IAuthRepository, AuthRepository>(); ta metoda tworzy repozytorium
za każdym razem kiedy nadchodzi request od klienta (czyli np się łączy, czyli jedna instancja na połączenie klienta)

Stworzenie AuthControllera - tu dużo rzeczy jest tymczasowe - stworzyc klase AuthController dziedziczaca po ControllerBase. W konstruktorze 
ma przyjmowac IAuthRepository które będzie zajmowac sie rejestracja i logowaniem od strony bazy, stworzyc async funkcje Register z TYMCZASOWO
string username i string password (potem to bedzie zserializowany json). Na poczatku kiedys bedzie validate request, potem trzeba zmienic username
na lowercase, sprawdzic czy taki user juz istnieje korzystajac z _repo, jesli nie zwrocic BadRequest, jesli nie istnieje stworzyc nowy obiekt User,
nadac mu user.Username = username, potem znowu wywolac funkcje Register z _repo, podajac usera i haslo. Na koncu TYMCZASOWO zwrocic statuscode(201)

DTO wstęp: dto to obiekt json ktory bedzie przesylany z angulara do api i bedzie zawierac dane usera. W api stworzyc folder dtos i klase UserForRegisterDto
z polem Username i Password. Potem w AuthController pozmieniac metode register tak zeby przyjmowala obiekt UserForRegisterDto a nie osobne pola.
Na samym poczatku metody register dodac punkt pauzy debuggera, stworzyc nowa konfiguracje debuggera, .NET Core, przy procesie do zaczepienia
wpisac "api" i dolaczyc do dotnet.exe ktory jest w folderze z api, potem wejsc do postmana, zrobic requesta post dla localhost:5000/api/auth/register,
w body dac raw i zmienic zawartosc na jsona , w nim dac { "username": "John", "password": "password" }, dzieki temu bedzie mozna sprawdzic czy 
metody do rejestracji dzialaja bez stworzenia frontendu do rejestracji. Po wyslaniu requesta debugger powinien zatrzymac kod i pokazac co sie
dzieje - rejestracja powinna pojsc ok, mozna potem sprawdzic w przegladarce sqlite. powinno zwrocic 201 created, przy drugim post dla takiego samego
hasla i username juz powinien zwrocic 400 bad request, przy pustym username i password powinno wciaz utworzyc, w kolejnym kroku poprawi sie to 
dzieki walidacji.

Validation requests w api: walidacja musi byc w miejscu gdzie są same dane wysłane przez usera, czyli login i hasło jako string, czyli UserForRegisterDto.
Nad deklaracja pola wystarczy dodać znaczek [Required], wtedy nie przejdzie empty string. przy haśle trzeba dodac Required i można dodać dodatkowe wymagania,
np StringLenhth od 4 do 8. Teraz w postmanie przy probie zarejestowania pustego usera wyskoczy error 400, dzieki temu ze AuthController ma atrybut [ApiController]
Po zakomentowaniu atrybutu po próbie zarejestrowania sie z empty stringami wyskoczy internal server 500, a konkretnie nullreferenceexception. Okazuje sie ze
username jest teraz nullem i konwersja na lowercase wywala wyjątek (można sprawdzic debuggerem). Gdyby [ApiController] nie bylo zakomentowane api "wywnioskowaloby"
że UserForRegisterDto pochodzi z strony i nie moze byc nullem. Mozna tez to osiagnac dodajac atrybut [FromBody] przed nazwa klasy (UserForRegisterDto) w metodzie Register
Bez ApiController trzeba zrobic walidacje (if (!modelState.IsValid) return BadRequest(ModelState);), wtedy dostaniemy juz bad request 400. Jednak najlepszą opcją
jest dodanie ApiController i usuniecie FromBody i walidacji przez ModelState.

Token authentication - zawiera 3 części - header z ingo o rodzaju szyfrowania i typie struktury (JWT, json web token), payload, czyli czesc przechowujaca informacje
np id, name. oprocz tego zawiera info tokenu, czyli date wygenerowania, date wygasniecia i date wejscia do uzycia. Te dwie czesci moga byc odczytane przez kazdego!
Ostatnia czesc to signature, czyli czesc ktora autoryzuje token. Tworzy sie go szyfrujac header i payload tokenu przy uzyciu sekretu jako soli (?). Sekret
jest trzymany na serwerze. Logowanie bedzie dzialalo tak że klient wysyla login i haslo, serwer odsyla token ktory klient zapisuje, a do kazdego kolejnego żądania 
klienta dołączany będzie token który potwierdza że user jest ok.

Tworzenie metody logowania: stworzyc UserForLoginDto ktore bedzie takie samo jak UserForRegisterDto ale bez obostrzeń, można przesłać wszystko, nawet puste. W AuthController
stworzyć metode login przyjmujaca UserForLoginDto. Najpierw musi sprawdzac czy taki user istnieje, korzystajac z _repo.Login i jesli userFromRepo bedzie nullem zwrocic
Unauthorized. Teraz celem funkcji jest wygenerowanie i wyslanie tokenu. Wszystkie jego czesci generuje sie klasami ktore potem laczy sie w jedno SecurityTokenDescriptior. 
Najpierw trzeba zrobić tablicę Claims zawierającą id i login, potem klucz. Klucz będzie trzymany w appsettings.json żeby mieć do niego dostęp z różnych części aplikacji,
więc dodajemy "AppSettings": { "Token": "dupa1234dupa1234" } (pamiętać że są dwa appsettings w zależności czy jesteśmy w trybie produkcyjnym czy deweloperskim), w konstruktorze
naszego AuthController dodajemy IConfiguration i pole _config żeby mieć dostęp do appsetings, pobieramy klucz do zmiennej i konwertujemy na byte[], tworzymy obiekt 
SigningCredentials podajac jako argumenty klucz i typ szyfrowania, potem tworzymy SecurityTokenDescriptior w ktorym Subject = claims, Expires = DataTime.Now.AddDays(cośtam) i 
SigningCredentials = creds. Na końcu tworzymy obiekt ktory tworzy jwt (JwtSecurityTokenHandler), tworzymy token uzywajac jego metody CreateToken z arugmentem tokenDescriptor
i zwracamy klientowi Ok(new {token = tokenHandler.WriteToken(token)})

Zmuszenie innych kontrolerów do autoryzacji - testowo użyjemy ValuesController - przed klasą dać znacznik [Authorize], dzieki temu kazda metoda z kontrolera bedzie wymagala 
logowania. Oczywiscie mozna zmusic jakas metode do zezwolenia na anonimowe logowanie, dajac przed metoda znacznik [AllowAnonymous]. Teraz trzeba poinformować api skąd ma brać
secret, jaka jest konfiguracja autoryzacji itd. W metodzie startup.cs w metodzie ConfigureServices dodać services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).
AddJwtBearer(options => {}). W wyr lambda przypisujemy TokenValidationParameters jako nowy obiekt TokenValidationParameters, i właśnie tam ustawiamy konkretne opcje. Pierwsza 
właściwość to ValidateIssuerSigningKey = true, która zaznacza że potrzebny jest secret key, drugi parametr to właśnie ten klucz i ścieżka do niego, czyli IssuersSigningKey =
new SymmetricSecurityKey(Configuration.GetSection(ścieżka do klucza w appsetings.json)), ostatnie to ValidateIssuer i ValidateAudience, oba na false, one służą do sprawdzenia
wystawcy tokena i odbiorcy tokena podczas sprawdzania tokena, póki co wszystko robimy na localhost więc damy na false. Na koncu w metodzie Configure przed UseMvc uruchamiamy 
app.UseAuthentication(). W postmanie przy metodzie get (!!!) na values/liczba powinno zwracac wartosc z bazy bo ustawilismy zeby pozwalalo anonimon, za to przy samo /api/values
juz nie bedzie dzialac. Zeby sie dostac do values trzeba sie zalogowac, wtedy dostaniemy token w body json, kopiujemy go i dodajemy nowy header z key Authorization i z value
Bearer tu_wstaw_token. Teraz values dziala.

Tworzenie formy do logowania - wejsc na getbootstrap i skopiować kod html z jakiegoś example np jumbotron (wszystko w <nav>), to będzie szkic naszej formy. Teraz robimy nowy
komponent "nav" w src/app (ppm/generate new component) i kopiujemy html z bootstrapa do nav.component.html Żeby aktywować nav w stronie głównej dołożyć do app.component.html 
na samym początku <app-nav>. Teraz zmienić navbar-brand na Dating App, wywalić button navbar toggler bo ono korzysta z jquery a my nie chcemy jquery, wywalić navbar collapse
Mają być 3 navlinki, Matches, Lists i Messages, wywalić navbar dropdown. Do tego dać 2 inputy dla loginu i hasła, zmienić submit na login i wywalić część "outline" w nazwie klasy.4
Na koniec wywalić fixed top z samej góry, teraz header będzie poniżej navbara.

Tworzenie formy do logownia - kazda forma html może byc zmieniona na forme angulara. Najpierw w nav.component robimy obiekt "model: any = {};", póki co pusty. Model będzie przetrzymywać
username i password z htmla. Robimy jeszcze funkcje login(), w niej console.log(model), tymczasowo, żeby sprawdzić czy wszystko działa ok.Teraz wracamy do nav.html i musimy oznaczyc 
ze forma html jest tez forma angulara, dodajac #loginForm="ngForm" w <>. Żeby aktywować ngForm w naszej apce  trzeba przejść do app.module i zaimportować: w sekcji imports dodac FormsModule, 
na samej gorze dodać import {FormsModule} from '@angular/forms'. Teraz w nav.html dodać  przy deklaracji kontrolki username i password a-ngModel, dać tab i aktywuje sie snippet. 
Zmienic binding na model.username, to samo dla hasla (model.password). Dla deklaracji  formy (nie przycisku submit) dodajemy ngSubmit)="login()", teraz klikniecie buttona 
aktywuje metode login() z pliku .ts Do inputow dodac znacznik "required" i name, bez name angular nie powiaze inputu html z modelem. Sprawdzic czy dziala. Jesli sie zalogujemy
z pustymi polami login i password wciaz bedzie proba logowania, mimo tego ze pola sa required, bo angular nie wie co zrobic jesli pola nie sa wypelnione. Zeby to zmienic dodac do
buttona w htmlu [disabled]=!loginForm.valid. Angular caly czas sprawdza kiedy forma jest "valid" i udostepnia takie parametry. Teraz kiedy zaznaczylismy że oba pola sa required valid
valid bedzie tylko wtedy kiedy w obu cos jest wpisane, parametr valid bedzie true, dzieki temu mozna wplywac na disabled.

Angular Service - specjalny obiekt angulara który służy do przekazywania i zapisywania danych pomiędzy częściami aplikacji które o sobie nic nie wiedzą, w tym wypadku do komunikacji 
a api. Dzięki niemu komponenty będą też odseparowane od siebie. W /src/app dodać folder _services i użyć ppm i wygenerować service auth (tylko plik .ts). @Injectable pozwala na 
wstrzykiwanie. providedIn wskazuje w którym module ma działać service, root = app.module. Trzeba też dodać info o service w app.module.ts - w providers dodac AuthService, dać tab
i vscode doda import. Teraz service może być wstrzykiwane do komponentów. W auth.service.ts dodać konstruktor z argumentem http: HttpClient (z angular/common/http, użyć tab).
Dodać zmienną baseUrl ze ścieżką do api/auth, doodać metode login ktora bedzie przyjmowala model : any (z navbaru), i ktora zwraca  
return this.http.post(this.baseUrl + 'login', model).pipe(
      map((response: any) => {
        const user = response;
       if (user) {
          localStorage.setItem('token', user.token);
        }
To powyżej wykonuje request http (post), przekazujac adres i cialo requestu czyli model z loginem i hasłem do logowania. Zajmujemy sie tez reakcja na http response, czyli plikiem json
Przez rxjs mapujemy odpowiedź do bloku kodu który zapisuje ją do zmiennej user, a następnie zapisuje do localStorage część pliku json która jest czystym tokenem.
Ten blok wykona się od razu po otrzymaniu odpowiedzi. Należy jeszcze zaimportować map z rxjs/operators

Injecting service in component: w konstruktorze nav.component dodać authService: AuthService (tab). Teraz przy metodzie login można użyc requestu http: this.authService.login(this.model)
(model to mode.username i model.password, zdefiniowane w pliku nav.component.html). Jako że service zwraca Observable, czyli czeka na odpowiedź od api, trzeba dodać 
.subscribe(next => {
      console.log('Logged in successfully!');
    }, error => {
      console.log('Failed to login!');
    });
Next to blok wykonywany jeśli subskrybowany Observable wykona się poprawnie, czyli jeśli dostaniemy odpowiedz od api. Error wykona sie jesli odpowiedzi nie dostaniemy. Sprawdzic czy dziala.
Po wejsciu w zakladke Network debuggera widzimy 2 wartosci login, pierwsza to cos w rodzaju headera, drugi to wysylane dane, mozna je zobaczyc w zakladce Headers. W Response widac zwrotny
plik json z tokenem ktory jest zapisywany do localStorage.

Conditional rendering Angular components - pobieramy z getbootstrap.com/docs/components/dropdown kod html, ten z <a>. Do nav.component.html wklejamy blok z bootstrapa. Teraz kosmetyka,
usunąć z dropdown-toggle btn i btn-secondary, zmienic nazwe na Welcome User, usunac wszystkie properties za id. Teraz usunac z wysuwanych linkow aria, zmienic nazwy na Edit Profile i Logout,
srodkowa zmienic na <div class="dropdown-divider"> Do dropdown-itemow dodac ikony (<i class="fa fa-user" albo fa-sign-out), dodac do dropdown-toggle text-light. Dalej nie da sie rozwinac
dropdown menu. 
Teraz dodajemy metody do sprawdzania czy user jest zalogowany - loggedIn tworzy zmienna const token = localstorage.getItem('token'), a nastepnie jest linijka !!token - to skrot od 
if(token != null) return true; else return false;, zapamiętać, ważne. Dodać też metode logout (localstorage.removeitem('token') + jakies info w konsoli). Teraz mozna wykoryzstac te metody w 
htmlu - blok z dropdownem powinien byc dostepny tylko dla zalogowanych userow, dodajemy wiec przy jego deklaracji a-ngIf, tab, zmienic expression na "loggedIn()". Teraz blok dropdown wykona
sie tylko wtedy jesli metoda z ngIf zwroci true. Blok z kontrolkami logowania (#loginForm) powinien byc za to rysowany jeśli user nie jest zalogowany, dodajemy wiec *ngIf="!loggedIn()" - teraz
musi byc zwrocone false zeby wszystko zadzialalo. Sprawdzic czy dziala, poki co dropdowna nie da sie rozwinac. Dodajmy jeszcze jakis tymczasowy przycisk do wylogowania - dodac nav-link pod
messages (Logout), dodac atrybut (click)="logout()", teraz po kliknieciu wykonuje sie funkcja logout, wszystko aktualizuje sie w czasie rzeczywistym bez odswiezania strony.

Adding Register components - dodać dwa komponenty - home z częścią "reklamową" strony i "register" z częścią rejestracji. Kurs dostarcza plik html ktory zawiera ładny layout komponentu w 
bootstrapie z dwoma zdaniami i dwoma przyciskami. Rzeczy bootstrapowe - mt-5 określa margines, mt=margin top, jest 6 opcji, czyli 5 to prawie najwiekszy odstep jaki da sie zrobic bootstrapem
Div do wyswietlania formy z rejestracja ma dopisek "col-4", co znaczy ze rzeczy wewnatrz divu beda sie wyswietlaly na 4 z 12 kolumn. W glownym htmlu aplikacji (app.component.html) zamiast h1 
dać <app-home>. Przy nazwie klasy buttonow dodac marginesy ("mr-2" albo "ml-2"). Do register.component.html tez wkleic szablon z kursu. W register.ts dodać model: any = {};, metody
register() i cancel(), póki co tylko z console.log. Teraz mówimy angularowi że to jest formularz - w register.component przy znaczniku <form> dodać #registerForm="ngForm" (ngSubmit) = "register()"
Przy polach username i password dodać znaczniki required, name="username" albo "password", snippet a-ngModel, tab i "model.username" albo "model.password". Przy buttonie cancel dodać (click)="cancel()"
Wrocic do home.component.html i w kontenerze na dole (tym z 4/12 kolumn) dodać <app-register>. Teraz mamy jednoczesnie rejestracje i wstep, a chcemy miec tylko jedno z dwoch. Zeby to zmienic 
wchodzimy do home.html i przy kontenerze z app-register dodajemy *ngIf="registerMode", a przy kontenerze z opisem (nie tym głównym bo inaczej zniknie wszystko, włącznie z rejestracją!) dodać 
*ngIf="!registerMode". Dodać jeszcze (click)="registerToggle()" przy przycisku register. Teraz w .ts dodac registerMode = false (domyślnie będzie opis a nie rejestracja), i funkcje registerToggle()
która zmienia registerMode = !registerMode. Teraz po kliknieciu na rejestracje opis znika, jednak nie da sie wrocic do trybu opisu. Dzieje sie to dlatego że przycisk cancel jest w app.register,
a metoda zmieniajaca registerMode w app.home, i póki co jedno nie umie odwoływać się do drugiego. W następnej sekcji to będzie poprawione.

Parent to child communication - bedziemy przekazywac wartosci z home.component do register.component . Na potrzeby przykladu musimy przeslac jakies dane, a w home takich nie ma, pobierzemy wiec je
z api (te testowe wartosci z bazy danych) - na poczatek w ValuesController.cs w API przy metodzie [HttpGet("{id"})] i zwyklym HttpGet dodajemy znacznik [AllowAnonymous] żeby móc łatwo przesłać dane
bez bawienia sie w tokeny (potem to sie usunie), Teraz values.controller powinien dzialac i pokazywac wartosci (wczesniej byl zaimplementowany w app.component, ale w konsoli byl blad 401 unauthorized)
Teraz skopiowac do home.ts metode getValues z value.component i dodac w kontruktorze httpClient i prop values: any i w kontruktorze uruchomic metode getValues. Docelowo bedziemy chcieli zastapic value
app.component, usuwamy wiec caly folder value i importy z value w app.module. Dodac w home.html <p> z ngFor let value of values a wewnatrz {{value.name}}, w app.html wywalic app-value. Sprawdzic czy
dziala, usunąć <p>, była testowo żeby sprawdzic czy pobiera wartosci z serwera. Teraz chcemy przerzucic values z home do register. Robi sie to dodajac do deklaracji <app-register znacznik
[valuesFromHome]="values". To pierwsze to nazwa prop wewnatrz register.ts, a to drugie to nazwa propa wewnatrz home.ts. W register.ts dodajemy linijke @Input() valuesFromHome: any;, dziala jak zwykla 
deklaracja zmiennej ale ze znacznikiem ze jest z inputu. Teraz zeby sprawdzic czy dziala to w praktyce dodajemy w register.html div form-group, wewnatrz niego label z info i select form-control a w 
nim option z ngFor value of valuesFromHome [value]="value">{{value.name}}. Teraz w stronie powinien byc selector z nazwami values.

Child to parent comunication - tu zrobimy cos co rzeczywiscie przyda sie w aplikacji, przycisk cancel w register.component zmieni wartosc home.component i w efekcie usunie część html z rejestracja i
przywroci tą ze wstępem. Do register.ts dodać @Output() cancelRegister = new EventEmitter(); (emitter z angular/core). Przekazywanie do rodzica dziala na zasadzie emitowania eventów, których nasłuchuje
rodzic. Event może zawierać dowolny obiekt. Teraz dodajemy do metody cancel() this.cancelRegister.emit(false). W ten sposób emitujemy wczesniej utworzony Event zawierając w nim boolean false, które 
przyjmie rodzic i zmieni za jego pomocą registerMode, który wczesniej ustawilismy tez na boolean. W home.html przy deklaracji app-register dodajemy znacznik (cancelRegister)="cancelRegisterMode($event)"
To pierwsze jest znacznikiem eventu (?), mało ważne, a drugie to nazwa metody w home.ts. $event to znacznik że w środku będzie event, w tym wypadku to tylko false. Dodac w ohme.ts metode 
cancelRegisterMode(registerMode: boolean), ktora bedzie zmieniala this.registerMode na registerMode przekazany z register.component. Mozna tez zauwazyc ze metoda registerToggle bedzie wywolana tylko raz
i zmieni wartosc na true, wiec zeby nie dawac programowi szansy na dziwne błędy zmienmy !registerMode na true.

Adding register method - otworzyc auth.service.ts, dodać metode register(model:any). Ona zwraca tylko http.post do "api/register" przekazujacy model. Całą resztą zajmie sie api i ef. Metoda ta zwroci jednak
Observable, musimy wiec pamietac zeby ja zasubskrybować przy wywolaniu. W register.ts w konstruktorze dodajemy authService i w metodzie register() wywolujemy this.authService.register(this.model).subscribe
(() => {console.log('registration successful!');}, error => {console.log(error);}). W wypadku sukcesu ( czyli (), to skrót (chyba) a i tak nie bedziemy korzystac z metody success) podac console.log o sukcesie,
w wypadku error podobnie. Dodac przykladowego usera w stronie, sprawdzic czy dodal sie do bazy. Sprawdzic co sie stanie jesli dodamy drugi raz tego samego usera i jaki bedzie naglowek errora, sprawdzic co sie 
stanie jesli ustawimy za krotkie haslo. Te bledy w nastepnej sekcji beda wyswietlane na stronie a nie w konsoli. Usunac z projektu czesc kodu do z wywolywaniem values w rejestracji (@Input).

Error handling - żeby sprwadzic jak dziala zarzadzanie wyjatkami w asp .net core dodac na poczatku metody Login() throw new Exception("testowy wyjatek"). Teraz próbując dostac sie do api/auth/login w postmanie
dostajemy 500 error z developer exception page, zawierającą wszystkie informacje o wyjątku. Próbując się zalogowac z poziomu angulara dostajemy 500 internal server error i failed to load login, no access-control
-allow-origin. Dzieje sie tak bo api próbuje przesłać exception page, która nie zawiera cors http headera i w efekcie klient nie zezwala na dostęp (albo odwrotnie(?)). Nie da sie ich dodac, wiec zignorujmy drugi
błąd. Exception page wyświetla sie bo jestesmy w trybie dewelopera, zmieniając w properties/launchSettings.json ASPNETCORE_ENVIRONMENT na Production i probujac sie zalogowac w postmanie dostajemy 500 internal error
bez zadnych informacji. Jedyna mozliwosc na uzyskanie informacji o bledzie to terminal serwera. Dając całą metodę login w bloku try catch, gdzie przy catch zwracany jest StatusCode(500, "cośtam") w postmanie w body
będzie wiadomość z "cośtam", jednak wkładanie całej funkcji do try catch nie jest dobrym pomysłem, dodamy wiec global exception handler.

Global exception handler, api - w Startup.cs w metodzie Configure w else (czyli wtedy kiedy jestesmy w trybie produkcji) dać:
 app.UseExceptionHandler(builder => {
                    builder.Run(async context => {
                        context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;

                        var error = context.Features.Get<IExceptionHandlerFeature>();
                        if(error != null)
                        {
                            await context.Response.WriteAsync(error.Error.Message);
                        }
                    });
                });
Ta część konfiguruje exception handler - każe mu wysyłać do klienta zawsze 500 InternalServerError (nawet jesli api ma zwracac inne errory, np unauthorized itd). Pozniej pobiera z wnętrza api error i jesli ten istnieje
dołącza wiadomość dołączoną do errora do responsa, a na samym końcu wysyła response. Zmienić na production mode, wysłać request w postmanie, teraz dostajemy w body message. Jednak w angularze dalej widzimy te same błędy,
bo dalej nie ma corsa. W głównym katalogu api tworzymy nowy folder Helpers, tworzymy statyczna klasę Extensions.cs. Tworzymy metode AddApplicationError(this HttpResponse, string message). W srodku dodajemy dodatkowe headery:
            response.Headers.Add("Application-Error", message);
            response.Headers.Add("Access-Control-Expose-Headers", "Application-Error");
            response.Headers.Add("Access-Control-Allow-Origin", "*");

))
Po dodaniu tego extension do response będzie ono miało 3 headery, pierwszy to error, dwa kolejne to headery ctor które pozwalają na wyświetlanie tej odpowiedzi po stronie klienta. Teraz musimy dodac headery do response:
przed wyslaniem dodajemy linijke context.Response.AddApplicationError(error.Error.Message); To wywoła statyczna funkcje ktora napisalismy chwile wczesniej. Sprawdzic czy dziala w postmanie, w headerach są nasze headery,
w kliencie jest już błąd "Failed to login".

Handling errors, angular - api musi byc caly czas w trybie production! Errory ktore dostajemy od api w konsoli wyswietlaja sie w calosci, a chcemy zeby przetwarzalo tylko messages. Tworzymy nową service error.intercepter.ts
ustawiamy ją jako @Injectable, tworzymy klasę (export class) ErrorInterceptor implements HttpInterceptor. Implementujemy interfejs, wiec musimy stworzyc metode intercept(). Przyjmuje ona req: HttpReqiest<any>, next: HttpHandler)
: Ovservable<HttpEvent><any>>. Po wywolaniu przechwytuje ona requesty i obsługuje je w skonfigurowany w kodzie sposob, szukajac bledow, czyli obiektow HttpErrorResponse. Pamietając że nasz header z errorem nazywa sie
'Application-Error', szukamy wlasnie takiego headera, jesli ten istnieje wrzucamy go do konsoli i zwracamy throwError. Dodajemy jeszcze warunek że jeśli error.status jest 401, to wtedy zwracamy throwError(error.statusText), żeby
przy 401 nie pokazywały się złe informacje. Musimy jeszcze stworzyc interceptor provider - ErrorInterceptorProvicer konfigurujący przechwytywanie requestow http. Dodajemy mu wlasciwosc privide: HTTP_INTERCEPTORS, ktora dodaje 
nasz ErrorInterceptor do angularowej tablicy interceptorów, useClass: ErrorInterceptor mówiący jaką klasę dodajemy do tablicy, oraz multi:true zaznaczjacy ze nie chcemy zastapic poprzednich interceptorow tylko dodac nasz do poprzednich
Teraz w app.module.ts dodajemy w providers ErrorInterceptorProvider i zapimportujemy ErrorInterceptorProvider. W nav.component.ts przy login error zamiast stringa przekazujemy po prostu error, ktory skorzysta z interceptora i sam 
stworzy poprawną wiadomość na podstawie info z headera. Jednak kiedy sprobuemy sie zarejestrowac i podajemy zle dane, error w konsoli bedzie wygladal zle. Tworzymy wiec stałą serverErro biorącą zawartość response.error, a nie header,
tworzymy pusty string z modalStateErrors. Jeśli serverError nie będzie nullem i jeśli jest typem object, to uruchamiamy pętlę która do pustego stringa dodaje dany error z pętli. W asp net core 2.2 zmieniono wewnetrzna klase error 
i teraz error zawiera dodatkowe informacje, a same wiadomosci są w serverError.errors. Można dodać jeszcze else if dla starszej wersji, z for(const key in serverError) zamiast erverError.errors
Na samym koncu funkcja robi throwError(modalStateErrors || serverError || "Server error"). Zwróci więc albo nasze sformatowane modelStateErrors, albo jesli te nie beda istniec czyste serverError, albo po prostu napis "Server Error" jeśli 
nie znajdziemy nic.

Alertifyjs - npm install alertifyjs --save, potem w angular.json w scripts dodać ścieżkę do alerfify.min.js, a w styles.css dodać impoty do alertify.min.css i alertify/css/themes/bootstrap.min.css, żeby nasze okna były bootstrapowe. 
Chcemy mieć możliwość dodawania alertów z alertify globalnie, z dowolnego miejsca aplikacji. Tworzymy więc alertify.service która będzie opakowywać kod wywoływania alertify w krótkie ładne metody. Dodajemy declare let alertify: any,
czyli zmienną która będzie umożliwiać korzystanie z "domyślnych" metod, które zaimportowaliśmy w angular.json scripts. Dodać metode confirm(message: string, okCallback: () => any) { alertify.confirm(message, function(e)) 
{if (e) { okCallback(); else {}}}}. Pierwsze to wiadomość w okienku, drugie to funkcja która ma się wywołać przy wybraniu "ok". Gdy ta 
zostanie wywołana wywołujemy metodę alertify o nazwie confirm przekazujac jej wiadomosc i funkcje z parametrem e. e to event który może być dowolnego typu, tutaj jest to clickEvent. function(e) jest pustą funkcją która ma się tylko
przekazać, a potem czekać na zmianę wewnątrz e. Zmianą jest kliknięcie które zmienia e na true albo false. Jesli zmieni sie na true, czyli user kliknie na przycisk "ok" wywołana zostanie funkcja wrzucana do naszej osobistej metody confirm.
Dołozyć jeszcze metode success(message: string) {alertify.success(message)} i error, warning, message działające tak samo. Service jest gotowa, trzeba ją dodać do app.module providers. Teraz uzyjemy service - w nav.component.ts 
dodac w konstuktorze alertify: AlertifyService, a w miejscach gdzie są console.log zamienić na this.alertify.[metoda] odpowiadajace wiadomosci. Podobnie w register.component (w error dać this.alertify.error(error)). Restart serwera, przetestować.

Jwt library - npm install @auth0/angular-jwt@2.0.0. Obecnie sprawdzanie tokenu odbywa sie w nav.component. Chcemy zeby wszedzie mozna bylo sprawdzic token, wiec potrzebujemy uslugi. Mamy juz taką authentication.service, więc dokładamy do niej
pole jwtHelper = new JwtHelperService i importujemy JwtHelperService. Tworzymy metode loggedIn() ktora najpierw pobiera token z dysku, a potem zwraca boolean !this.jwtHelper.isTokenExpired(token). Ta metoda sprawdza czy token istnieje i czy 
jest poprawny, zwraca false tylko jesli wszystko jest ok. My chcemy miec odwrotnie, więc dajemy !. Przechodzimy do nav.component.ts i zmieniami zawartosc metody loggedIn na return this.authService.loggedIn(); Teraz token jest sprawdzany dokładniej.

Zmiana "Welcome User" na "Welcome [nazwa]" - w auth.service tworzymy pole decodedToken: any i w metodzie login zaraz po zapisaniu tokenu wywolujemy znowu this.jwtHelper.decodeToken(user.token). Nazwę użytkownika możemy wyciągnąc z tokenu. W nav.html
przy tekście welcome dodajemy {{authService.decodedToken.unique_name}}. auth_service będzie podkreślone, ale to kwestia tego że jest prywatne. Mimo wszystko po zalogowaniu teraz bedzie pokazywac imie. Jednak to działa tylko przy logowaniu, po 
refreshu to nie bedzie dzialac, bo przypisywanie tokenu do decodedTokem bedzie sie odbywac tylko w metodzie login i unique_name nie bedzie istnieć. Dodając po decodedToken? znak zapytania error w konsoli zniknie, ale dalej nie bedzie pokazywac imienia.
Zostaje jeszcze error przy authService, jest dlatego że w js nie ma podziału na prywatne i publiczne pola (a w ts jest taki podział) i nawet jeśli jest private to html może się do tego odwołać (!). Zamienić authService na public żeby się tego pozbyć.
Z tym że username jest widoczny tylko przy logowaniu można sobie poradzić w prosty sposób, wywołując metodę odczytującą token na samym początku działania strony, czyli w app.component.ts. Ten komponent nie ma jednak onInit, trzeba zrobić class extends
OnInit, dodać konstruktor przyjmujacy authService: AuthService) i metode ngOnInie() która pobierze token i jeśli ten istnieje wywoła authservice.decodedtoken = this.jwtHelper.decodeToken(token). Teraz powinno działac w kazdym wypadku. Na koncu zmienimy 
nazwie pierwsza litere na wielka. W htmlu w {{ | titlecase}} dodajemy titlecase i html zrobi reszte.

Ngx bootstrap i dropdown menu - npm install ngx-bootstrap@3.0.1 --save. Import - w app.module w imports dodajemy sekcje z instrukcji droptown (każdy komponent ma swój import) i import BsDropdownModule. Szukamy dropdown trigger by <a>, wchodzimy w 
nav.html i szukamy klasy dropdown, dodajemy znacznik dropdown, w <a> niżej dodajemy dropdownToggle, a w dropdown-menu dodajemy *dropdownMenu. To znaczniki informujące ngxbootstrap że chcemy mieć w tych miejscach dropdownToggle. Teraz kosmetyka - wrzucamy 
wszystko z nav.html w div class="containter" oprocz 1 i ostatniej linijki żeby zbliżyć wszystko do siebie. Dodajemy do class dropdown-menu mt-3 żeby pojawialo sie troche nizej, wchodzimy w nav.css i robimy .dropdown-toggle, dropdown-item{cursor: pointer}, usuwamy nav-item
logout i dodajemy (click)="logout()" do dropdown-item logout, wczesniejsza wersja byla tymczasowo bo nie mielismy jak dostac sie do przycisku. Dodajemy jeszcze *ngIf("loggedIn()") w navbar-nav mr-auto, żeby nie pokazywac opcji typu matche, wiadomosci 
niezalogowanym userom. 

Bootswatch themes - npm install bootswatch, styles.css, import po bootstrap.min.css - dist/united/bootstrap.min.css. Zmienic w nav.component.html navbar navbar-expand-mds navbar-dark bg-dark ostatnie na bg-primary. Wrzucic na repo.

Routing - stworzyc w src/app komponenty member-list, lists i messages, ktore beda odpowiadac kolejnym czesciom strony - przegladanie osob, pary i wiadomosci. Teraz w src/app dodajemy pusty plik routes.ts. Tworzymy export const appRoutes: Routes importowane z
@angular/router. To jest tablica routes, która ustala do którego komponentu ma przekierowywać konkretny adres po localhost. Wewnątrz [] dodajemy { path: 'home', component: HomeComponent}. Path to adres, component to nazwa komponentu (trzeba zaimportować). W taki
sam sposób dodać routing do lists, members i messages. Dodać jeszcze path '**', component: HomeComponent, pathMatch: 'full'. ** oznacza wszystkie adresy które nie są wcześniej opisanymi adresami. Dzieje sie tak bo router ma zasadę "pierwsze pasujące", czyli 
szukając adresu leci od początku do końca listy appRoutes i gdyby ** było na początku nie brałoby pod uwagę reszty, czyli każdy adres przekierowałoby do home. Dodać router do app.module.ts, w tablicy imports dodac RouterModule.forRoot(appRoutes), czyli zasady 
routowania które wcześniej skonfigurowaliśmy.

Linki w navbarze używające routingu - w nav.component.html w linkach do matches, lists i messages zamiast usunac href i dodac info o routingu (snippet a-routerLink). W [routerLink] zmienić '/routePath' na '/lists' i tak dalej, drugie jest zwiazane z bootstrapem,
po uzyciu snippetu widac ze klasa <li> została zmieniona na "nav-item active". Usuwamy active i kopiujemy do deklaracji <li> część z routerLinkActive i zmieniamy ="router-link-actice" na ="active". Zrobić tak z każdym z 3 linków, zrobic tez tak samo z napisem 
DatingApp który będzie przekierowywać do /home. Po sprawdzeniu przekierowuje do podstron, ale html się nie zmienia. Dzieje sie dlatego ze mamy ustawione na sztywno app.component.html <app-home>. Trzeba zastąpić to czymś co będzie podmieniało go na html aktywnego 
kopmonentu. Zmienić na <router-outlet>. Teraz wszystko działa. 

Przekierowywanie do komponentow przy logowaniu i wylogowaniu - w nav.component.ts w konsturktorze dodać private router: Router. W metodzie login() dodać this.router.navigate(['/members']) w next  albo complete ( czyli () => { }); , pusty nawiast przy subscribe 
to zawsze complete). Do metody logout dodac navigate(['/home']).

Zabezpieczenie dostepu do komponentow dla niezalogowanych userów (routeguards) - w src/app dodać folder _guards. Nie mamy mozliwosci dodac wygenerowac guarda ppmem, ale mozna to zrobic z konsoli. cd do /_guards i wpisać ng g guard auth --spec=false. W pliku
auth.guard.ts usunąć next i state. Usunąć możliwość zwracania Observable<boolean> albo Promise<boolean> (ps to jest unia (?)). Usunąć niepotrzebne importy. Dodać konsturktor z AuthService, Router i Alertify. W canActivate dać if(this.authService.loggedIn()) 
{return true; else this.alertify.error('U shall not pas'); this.router.navigate(['/home']); return false; } Gdy user bedzie zalogowany zwrocic true, gdy nie wyswietlic wiadomosc i przekierowac do strony glownej. Dodac info o guard w app.module providers (AuthGuard)
i włączyć używanie guarda w routes.ts. Testowo w części z members dodać , canActivate: [AuthGuard]. Sprawdzic czy niezalogowany i zalogowany user moze dostac sie do members.

Guard do wielu komponentow naraz - w routes.ts dodamy "dummy route" czyli pusty pojemnik na inne routes. Po home dodać { path: '', runGuardsAndResolvers: 'always', canActivate: [AuthGuard], children: [tu wkleic konfigi routingu 3 komponentow]}. Usunąć canActivate z 
members, był tylko testowo. Teraz możemy użyć jednej konfiguracji do wielu komponentow, dodajac kolejne tylko do children. path '' jest dlatego ze jest wymagana a jesli jest children to path rodzica i children sumuja sie, czyli gdyby bylo 'a' a children 'lists' to
link do lists byłby 'alists'. Dając pusty string zapobiegamy temu i mozemy uzywac czystych nazw komponentow. Problemem jest jednak to że po zalogowaniu sie i wyjsciu z zakladki i wejsciu z powrotem do czystego localhost:4200 aplikacja nie wie gdzie przekierowac 
i pokazuje pustą stronę. Klikając w link wyskakuje bład "Outlet is not activated". Dzieje sie dlatego że nie mamy ustawionego routingu do strony głównej. Musimy więc zamienić w routes.ts wszystkie redirectTo: 'home' na ''. Teraz pusta strona będzie działać, sprawdzić.

Rozszerzanie modelu usera w api - robimy apke randkową więc potrzebujemy więcej pól w klasie User - dodajemy string Gender, DateTime DateOfBirth, string KnownAs, DateTime Created, DateTime LastActive, string Introduction, string LookingFor, string Interest, string City,
string Country, ICollection<Photo> Photos. To ostatnie ma byc osobna tabela zdjęć powiązanych z userem, trzeba stworzyc osobno klase Photo. Pola: int Id, string Url, string Description, DateTime DateAdded, bool IsMain. Musimy jeszcze dodac do DataContext.cs informacje
że chcemy tez wrzucic do bazy danych obiekty Photo, dodajemy public DbSet<Photo> Photos {get; set;}. Tworzymy nową migrację, NIE ROBIMY DATABASE UPDATE. W pliku migracji widzimy że wewnatrz nowej tabeli Photos jest dodatkowe pole UserId - sql'owy łącznik pomiedzy dwoma 
tabelami. Niżej w ustawieniach tej tabeli widzimy pole onDelete: ReferentialAction.Restrict); Dzięki temu gdy usuniemy usera tabela photos nalezaca do tego usera zostanie, a UserId w niej zostanie zmienione na null. Nie chcemy tego robic, chcemy zeby zdjecia usera 
byly usuwane razem z userem. Cofamy więc migrację.

Potencjalne problemy z migracjami - gdy zaaplikuje sie migracje a potem chce sie ja cofnac powinno sie uzywac dotnet ef database update [nazwa_wczesniejszej_migracji] (bez daty). Jednak kiedy uzywamy sqlite okazuje sie ze metoda down z migracji nie moze zostac wykonana 
bo sqlite nie obsluguje dropColumn. Najlepszym sposobem w tym momencie jest zrobienie database drop, czyli usuniecie calej bazy, usuniecie ostatniej migracji i zrobienie database update. 

Relacje pomiedzy klasami w tabeli - najprostsza metoda zeby ef usuwał zdjęcia razem z userem to po prostu dodanie propa User User i int UserId. Dzięki temu ef nie doda ich automatycznie i rozpozna że jedno musi byc powiazane z drugim i w przypadku usniecia usunie kaskadowo,
czyli usunie usera i photos. Zrobić database update.

Generowanie danych do bazy - uzyc json-generator.com i snippetu z .txt z kursu. Pierwsza porcja ma mieć username female i gender female, password: 'password'. W folderze Data stworzyc UserSeedData.json, skopiowac wygenerowany tekst. Zmienic w configu username male i gender
na male, wygenerowac i skopiowac znowu, poprawic nawiasy zeby json byl poprawny. W Data stworzyc klase Seed.cs z konstruktorem DataContext context żeby móc wrzucic pliki z jsona do bazy danych, zrobic metode SeedUsers(), w srodku stworzyc pole userData = System.IO.File.
.ReadAlltext("Data/UserSeedData.json"). To skopiuje zawartosc jsona do zmiennej. Teraz musimy to zserializowac do obiektow User - stworzyc pole users = JsonConvert.DeserializeObjects<List<User>>(userData); teraz users to lista zdeserializowanych obiektow User.
teraz kazdemu z nich musimy nadac poprawne hasło. Stworzyc foreacha in users, w nim byte[] passwordHash, passwordSalt i wywolanie metody CreatePasswordHash("password") (każde hasło to będzie password), potem user.PasswordHash = passwordHash, passwordSalt tak samo, zmienic
username na ToLower(). Metode CreatePasswordHash skopiowac z AuthRepository zeby nie dodawac sobie roboty, seed to i tak bedzie wywolany raz. Na koncu loopa zrobic _context.Users.Add(user), a poza loopem _context.SaveChanges(). Teraz dodac info o Seed do Startup.cs -
w ConfigureServices dodac services.AddTransient(Seed), w konstruktorze Configure dodac Seed seeder, i w metodzie zaraz przed UseCors wywolac seeder.SeedUsers(). Upewnic sie ze baza danych jest pusta (zeby nie mieszac z id), zrobic dotnet run, zakomentowac seeder.SeedUsers().
Sprawdzić bazę DB Browserem. 

Tworzenie repozytorium do Userów - w Data robimy interfejs IDatingRepository - podkładkę pod repozytorium, żeby każde przyszłe repo wykorzystywało dane metody. Dodać void Add<T>(T entity) where T: class; - T to klasa szablonowa, oznaczenie z where sprawdza czy T jest klasą, 
nie może być typem zmiennej. Dodać jeszcze Delete tak samo i Task<bool> SaveAll();. SaveAll ma być asynchroniczne więc musi być taskiem, bool bo bedzie zmieniac 0 albo więcej elementow w bazie. Jesli zwroci 0 to saveall zwroci false, to oznacza ze nie zapisalo albo byl blad, 
jesli zwroci cokolwiek innego to zwroci true, czyli wszystko ok. Dodać jeszcze Task<IEnumerable<User>> GetUsers() i Task<User> GetUser(int index). Mają zwrócić usera/ów z bazy. Stworzyć klasę DatingRepository która ma implementować interfejs z konstruktorem przyjmujacym DataContext
context, w add zrobic _context.Add(entity). Nie uzywamy asynca bo add nie dodaje czegos do bazy, tylko do ramu, a samo zapisanie do bazy odbywa sie przez metode SaveAll. Z Delete zrobic podobnie, tylko ze _context.Remove. GetUser() ma tworzyc zmienna ktora zapisuje usera
(bierze sie z metody _context.Users.Include(p=> p.Photos).FirstOrDefaultAsync(u=>u.Id == id, zdjęcia nie są domyślnie pobierane do klasy, bo są uznawane jako navigation properties, musimy je więc dodać ręcznie, metodą include. Później używamy FirstOrDefaultAsync podając id). 
Na końcu zwracamy znalezionego usera. Zmienic metode na async. Z GetUsers() zrobić podobnie tylko uzyc ToListAsync(); SaveAll() ma return await _context.SaveChangesAsync() > 0;. To dziala tak ze SaveChangesAsync zwraca int = ilosc zmian, a > 0 dziala jako skrot ktory zwraca true
jesli wartosc zwrocona przez SaveChangesAsync jest > 0, w innym wypadku zwraca false. Dodać info o repo w Startup.cs ConfigureServices. pod AddScoped<IAuthRepository, ....> dodać services.AddScoped<IDatingRepository, DatingRepository>(). Część z bazą jest już ok, teraz zostalo 
przesylanie wartosci przez internety.

Users controller - w Controllers stworzyc UserController, kazac tej klasie dziedziczyc po ControllerBase, dodać przed klasą znaczniki [Authorize] (KONIECZNIE JAKO PIERWSZY!), [Route("api/[controller]")] żeby uruchamiało ten kontroler przy api/users i [ApiController]. W kontruktorze
dodać IDatingRepository. stworzyc metode public async Task<IActionResult> GetUsers() ze znacznikiem [HttpGet], w srodku zmienna users ktora korzysta z repo (_repo.GetUsers();) i zwraca return Ok(users);, potem GetUser(int id) ze znacznikiem [HttpGet("{id}")] ktore dziala podobnie.
W launchSettings.json przełączyć na Development, zrestartować serwer, wlaczyc postmana, zrobic request: get http://localhost:5000/api/users . Powinno wyskoczyc 401 unauthorized, bo w requeście nie ma tokenu (cały mechanizm logowania i tokenów został podłączony do klasy jednym [Authorize]).
Wejść postmanem na auth/login, podać w jsonie dane jakiegos usera (teraz nie ma Boba i Johna, sprawdzić w bazie jakie imiona mamy!). Skopiowac uzyskany token, dodac header przy users tak jak wczesniej. Wyskocza albo nie do końca poprawne dane albo expected ',' instead of ''. Sprawdzic
zrodlo problemu w terminalu api. Dzieje sie to przez "self referencing loop detected for property 'user'". Dzieje sie to dlatego ze w User jest "navigation property" Photo, a w Photo jest pole User które odwołuje się do tego samego Usera. JsonSerializer myśli że to jest nieskończona pętla
odwołująca się do samej siebie, ale tak naprawde odwolanie dzieje sie tylko raz. Teraz wystarczy wyłączyć wywoływanie wyjątku przy wykryciu czegoś takiego - do ConfigureServices w Startup przy linijce AddMvc na końcu dodać kropkę i AddJsonOptions(opt => { opt.SerializerSettings.
ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHand}). Teraz wszystko jest ok, dostajemy wszystkie informacje. I to jest problem, bo do klienta przychodzi json z np hashem i salt. 

Żeby to zmienić stwórzmy nową klasę UserForListDto w folderze DTOs. Kopiujemy do niej zawartość User.cs i usuwamy po kolei pola których nie chcemy wysyłać - passwordHash i passwordSalt, zmieniamy DateOfBirth na int Age, usunac Introduction, LookingFor, Interests, dodac jeszcze string PhotoUrl.
UserForList ma przechowywac dane potrzebne tylko do strony z listą osób, gdzie będzie tylko zdjęcie profilowe i podstawowe informacje. Potrzebujemy jeszcze dto dla informacji pojawiających się po kliknieciu na kogos z listy - bardziej szczegółowych. Tworzymy UserForDetailedDto.cs, robimy tak jak w
poprzednim, wywalic hasla, zmienic date na wiek, zostawic wszystko inne i dodac string photourl z profilowym i dodatkowo ICollection<Photo> Photos ktore ma zawierac wszystkie zdjecia usera. Teraz musimy stworzyc jakis sposob na przekonwertowanie klasy User.cs na UserForListDto albo 
UserForDetailedListDto. Mozna to zrobic automatycznie uzywajac AutoMappera.

Automapper - Ctrl+P (musi byc zainstalowany nuget plugin w vscode), nugget add package, automapper i wybrac AutoMapper.Extensions.Microsoft.DependencyInjection, najlepiej 4.0.1. Dodać automappera w Startup.cs ConfigureServices (AddAutoMapper();), przejsc do UserController.cs, dodac 
do konstruktora IMapper mapper. Przy metodzie GetUser dodac zmienna userToReturn = _mapper.Map<UserForDetailedDto>(user), zmienic return na Ok(userToReturn). Podobnie zrobic z GetUsers, tylko ze tam uzyc Map<IEnumerable<UserForListDto>>(users). Jednak automapper nie bedzie umiał sam
dokonać konwersji, trzeba stworzyc plik go konfigurujący. Dodajemy w Helpers AutoMapperProfiles.cs, klasa ma dziedziczyc po Profile, w konstruktorze dodac CreateMap<User, UserForListDto>(); i drugą mapę do CreateMap<User, UserForDetailedDto>(); AutoMapper jest convencion-based, czyli 
samodzielnie mapuje na podstawie nazw pól. Zadziała to przy większości pól naszych Dto oprócz PhotoUrl i Age. Sprawdzic w postmanie czy dziala. U mnie automapper wyrzucil wyjatek, w kursie nie, ale w jednym i drugim wypadku nie umiał przekonwertować do age i photoUrl. Do tego photos w jsonie 
też mają za dużo informacji. Trzeba więc dodać  w konfuguracji ręczne przekierowanie pól. Dodajemy więc kolejne Dto, PhotosForDetailedDto.cs, w środku 5 pól z photo.cs - id, url, description, dateadded i ismain. W UserForDetailedDto.cs zmienic Photos z kolekcji Photo na kolekcje 
PhotosForDetailedDto, dodać również mapę CreateMap<Photo, PhotosForDetailedDto>(); To mapowanie zadziała od razu bo nie ma żadnych różnic w polach. Teraz w mapie User do UserForListDto dodajemy .ForMember(dest => dest.PhotoUrl, opt=>{opt.MapFrom(src=>src.Photos.FirstOrDefault(p=>.pIsMain).Url);})
to dla każdego obiektu który konwertujemy zamienia photoUrl na url pierwszego ze znalezionych zdjęć w IEnumerable dla tego membera które ma IsMain == true. Zrobic to samo w mapie dla UserForDetailedDto. Została jeszcze kwestia wieku. Żeby policzyć wiek najlepiej stworzyć metodę która dołączy do 
c#-owej klasy DateTime. Tworzymy wiec metode CalculateAge(this DateTime theDateTime) w Extensions.cs. This w argumencie sprawia ze rozszerzamy klase DateTime. Wewnatrz niej stworzyc var age = DateTime.Today.Year - theDateTime.Year. To nie zadziala zawsze, bo uzytkownik mogl jeszcze nie miec urodzin.
Dlatego musimy jeszcze dodac if(theDateTime.AddYears(age) > DateTime.Today) age--;. Jeśli warunek jest spelniony to znaczy ze uzytkownik nie mial jeszcze urodzin w tym roku i trzeba obnizyc go o 1. Na koncu return age;. Teraz w AutoMapperProfile dodac kolejną kropkę i .ForMember(dest => dest.Age, 
opt => {opt.ResolveUsing(d=>d.DateOfBirth.CalculateAge());}); ResolveUsing oznacza ze nie chcemy przekazac bezpośredniej wartości, tylko obliczyć ją na podstawie zmiennej w naszym User. Skopiowac ten blok do mapy dla UserForDetailDto. Sprawdzic w postmanie, teraz wszystko powinno byc ok.