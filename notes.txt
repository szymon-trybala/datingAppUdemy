.net core sdk (cli, to z vs2019 to co innego)
node.js najnowsze lts, npm ważny
vscode
db browser for sqlite 
postman

baza danych -> orm (object relation mapping, obiekty c# tworzące się na podstawie danych z bazy) -> api (umożliwia dogadanie sie 
orm ze spa) -> spa(angular) -> przeglądarka

najprostsze możliwe przekazanie danych z bazy do przeglararki, potem stopniowa rozbudowa

typ projektu .net core - asp net core web api żeby 3 warstwy były maksymalnie niezależne
dodać -o lokalizacja -n nazwa

Rozszerzenia do vscode:
c# od ms
c# extensions do szybkiego tworzenia klas 
nuget package manager

Projekt c# - Program.cs = main i CreateWebHostServer (tworzy Kestrel web server)
	Startup.cs = konfiguracja web servera - env (developer environment czy PRODUKCJA, to drugie daje hsts czyli powiazanie z https)
	PÓKI CO zakomentować to z https, do tego dodaje do web servera mvc framework który przekierowuje requesty do odpowiedniego
	kontrolera
	value controller - przekierowanie do odpowiedniego kontrolera odbywa sie przez 

	ctrl + slash = komentowanie linii

	Dotarcie do strony którą obsługuje ten kontroler:  http://localhost:5000/api/values
    	localhost bo serwer jest tam gdzie klient, 5000 bo to port kestrela, api bo route linijka nizej, values bo bierze 
        pod uwage slowo przed slowem "controller"

	bloki z httpGet, HttpPut, HttpPost uruchamiają ten blok dla konkretnych requestów http o tych nazwach.

launchSettings.json - konfiguracja serwera kestrel, ustalanie portow itd
Ctrl+tylda = terminal, dotnet run
Domyślnie nie będzie działać bo trzeba otworzyć /api/values żeby serwer przetworzył jakieś żądanie

Konfiguracja typu debugowania itd - appsetings.json, appsetingsDevelopment.json
Zmiana trybu: launchSettings.json - ASPNETCORE_ENVIRONMENT
dotnet watch run - uruchamia serwer i restartuje go przy zmianach kodu

Tworzenie modelu, czyli klasy która przechowuje dane z bazy (Value.cs) - na początku bardzo prosty
prop + tab = autogenerowanie klasy
Entity Framework = łączenie modelu (entity, w tym wypadku klasa Value) z bazą - stworzenie klasy (DataContext.cs)
która to zrobi - nowa klasa dziedziczy po klasie DbContext
Ctrl+kropka = autosugestie!
ctor + tab = autogenerowanie konstruktora
Konstruktor musi mieć jako argument klasę DbContextOptions<DataContext> : base (options)
DataContext powinno zawierać klase DbSet<Value> która przetwarza zapytania linq na zapytania do bazy i tworzy bazę. 
Value to wcześniej utworzony model (entity). Nazwa obiektu to nazwa tabeli w bazie

Poinformowanie api o nowej bazie i klasie value - w Startup.cs w metodzie ConfigureServices dodajemy service adddbcontext,
w <> dodajemy nazwę klasy datacontext i przekazujemy w opcjach przez wyr lambda typ bazy, tutaj sqlite
Zainstalować sqlite - jeśli jest addon nuget - ctrl+shift+p, -> nuget add package -> Microsoft.EntityFrameworkCore.Sqlite
Connection string dodaje się w appsetings.json - dzięki temu można go wywołać w dowolnym miejscu i zawsze bedzie dostepny, nawet w 
developement mode, bo json developementa nadpisuje zwykly, jesli w zwyklym bedzie rzecz ktorej nie ma w develoepement to jej nie nadpisze
 "ConnectionStrings": {
    "DefaultConnection": "Data Source=DatingApp.db"
  },
wewnatrz 1 nawiasu wasatego w appsettings.json
dostanie sie do tego z c#: Startup.cs - Configuration.GetConnectionString("DefaultConnection") - znajduje sekcje o nazwie DefaultConnection

Tworzenie bazy: dotnet ef migrations add InitialCreate - to sprawdzi nasze dbcontext (które zawierają info o values), sprawdzi gdzie
chcemy zapisać bazę (Startup.cs - AddDbContext), wykryje które pole klasy to Id i da je jako primary key itd.
Migration tworzy PLAN przetworzenia danych z kodu do prawdziwej bazy danych
dotnet ef database update - aktualizuje plik z danych migracji (albo go tworzy jesli go nie ma)
Otworzyc baze przez Db Browser for SQLite i dodac kilka rekordow

ctrl+p = go to file
Powiązanie bazy z metodą httpget - wstrzyknięcie datacontext do metody przez utworzenie w klasie valuescontroller i prywatne pole
z DataContext
Potem w httpget zmiana na IActionResult i wewnątrz stworzenie zmiennej do której wrzuca się _context.Values.ToList() (DataContext
zawiera wszystkie potrzebne metody). Potem zwrócić klientowi wewnatrz response Ok (czyli Ok(values))
HttpGet("{id}") podobnie, tylko w metodzie GetValue przekazac int id, a potem zeby sprwadzic ktora to zmienna uzyc wyrazenia lambda
var value = _context.Values.FirstOrDefault(x => x.Id == id);

Otworzyc postmana, sprawdzic czy wszystko jest ok "http://localhost:5000/api/values", można dodać potem "/3" itd, jesli przekroczymy
ilosc rekordow w bazie to zwroci pusta strone i status 204 no context bo uzylismy metody FirstOrDefault zeby nie wywaliło wyjątku

Http requesty asynchronicznie: zmienic metode ktora uruchamia request na async Task<IActionResult>. Teraz metoda bedzie zwracac 
asynchroniczne zadanie. Przy miejscu które może trwać dużo czasu i chcemy żeby nie blokowało całego programu dodajemy await,
dodatkowo trzeba zmienic metode przy await na asynchroniczna (ToListAsync). Każdy request powinien być async

Zainstalować angular cli przez npm, użyłem wersji 6.2.9 lts, stworzyć projekt przez ng new DatingApp-SPA

Użyte moduły i ich wersje są opisane w package.json, główny folder aplikacji Angulara to src/app. Angular ma komponenty, czyli coś
w rodzaju klas z powiązaniami. Domyślnie w pliku index.html uruchamiany jest komponent z selectorem "app-root", czyli ten w 
domyślnym pliku app.component.ts. app.module.ts to plik z modułem, czyli czymś co ładuje poszczególne komponenty.
Moduł jest ładowany bezpośrednio w pliku main.ts. w nim jeszcze jest info że aplikacja jest pod przeglądarkę (platformBrowserDynamic)
i że chcemy uzywac bootstrapa w module (bootstrapModule(AppModule)), co włacza tez bootstrapa na każdy komponent uruchamiany przez moduł
main.ts jest uruchamiany mimo że w index.html nie ma zadnej informacji o nim dzieki webpackowi w angularze, ktory pakuje wszystko do js
i wstrzykuje do htmla w trakcie kompilacji (?).
Uruchomic projekt angulara (ng serve), bedzie sluchac na porcie 4200

Dodac kilka rozszerzen do vscode dla angulara: Angular v7 Snippets, Angular Files do szybkiego tworzenia plkikow, ANgular Language 
Service (goto definition), Angular2-switcher do szybkiego przełączania pomiedzy plikami ts, html i css, auto rename tag, bracket pair
colorizer, debugger for chrome, path intellisense, prettier do autoformatu, tslint do podkreślania.

Tworzenie http requestów w angularze: stworzyć komponent (ppm i create component, value wtedy zrobi folder z wszystkimi potrzebnymi
plikami). Dodało też w pliku app.module informacje że korzystamy z komponentu value. 
Klasy do requestów są w pliku angular/common/http, trzeba zaimportować je w app.module.ts. Potem w value.component.ts 
tworzymy pole values:any, które będą przechowywać dane z serwera aspnet i metodę getValues, która korzysta z httpclienta angulara
i robi request na localhost:500/api/values, a potem subskrybuje, czyli zapisuje odpowiedź do values: 
getValues() {
    this.http.get('http://localhost:5000/api/values').subscribe(response => {
      this.values = response;
    }, error => {
      console.log(error);
    });
Dodać jeszcze wywołanie metody getValues w ngOnInit, czyli metodzie wywołującej się po załadowaniu komponentu
Alt+O = przejście do http danego komponentu, Alt+U = przejście do ts danego komponentu
W stronie tytułowej angulara (app.component.html) dodać znacznik <app-value>, który uruchomi komponent value (nie będzie go widać na stronie
bo nie ma backendu, ale można go zobaczyć w konsoli). W konsoli jest info o Access-Control-Allow-Origin blocked blabla, trzeba to poprawic i dodac cors

CORS pozwala na ustalenie którzy klienci mogą mieć dostęp do naszego api (np wywołanie localhost:5000 z localhost:4200). Zeby to zrobic
najpierw w metodzie configureServies trzeba dodać Cors (services.AddCors()), a potem go ustalić na co ma pozwalać (w metodzie configure
dodać app.UseCors(x => x.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());, to pozwala na wszystko wszystkim, później to się zmieni

Wyświetlenie wartości na stronie, a nie w konsoli chroma: w value.component.html przy znaczniku p dodać pętlę angulara która pozwala na wrzucanie elementow na strone:
<p *ngFor="let value of values">
  {{value.id}}, {{value.name}}
</p>
values to var do którego przesyłane są dane z api, mozna sie dostac do poszczegolnych id i name, sukces XD

Bootstrap i FontAwesome: npm install bootstrap font-awesome
potem w głównym pliku css zaimportować bootstrap.min.css a potem font-awesome.min.css, potem w htmlu componenta można usunąć znacznik style

git: wywalic .git z spa, dodac gitignore dla api, zrobic git init w głównym folerze aplikacji, stworzyć repo na githubie, zrobić remote
add origin [adres], potem pierwszy commit i push to 

dodanie modelu usera: stworzyc klase z id, loginem, hashem hasla i solą (oba to byte[]), dodac info o tej klasie w datacontext, zrobic kolejna
migracje, potem dac dotnet ef database update

Repository interface - kolejna warstwa abstrakcji ktora jest interfejsem. Zawiera szkielet wszystkich metod ktore beda potrzebne api do 
wykonania jego metod, i kazda klasa ktora bedzie pobierac dane z bazy musi implementowac ten interfejs, dzieki czemu api bedzie po czesci 
niezalezne od frameworków.

Stworzenie interfejsu: w folderze data stworzyc interfejs IAuthRepository, zrobic 3 taski (metody async), login ktory przyjmuje nazwe usera, 
haslo a zwraca obiekt user (w jaki sposob ten user zostanie stworzony to juz kwestia konkretnego AuthRepository), register który zwraca usera
i przyjmuje usera i password, i UserExists ktory przyjmuje string username a zwraca boola. 

Rejestracja - najpierw tworzymy klase AuthRepository ktora implementuje interfejs IAuthRepository, w konstruktorze będzie DataContext dzięki
któremu bedzie mozna przesylac dane do bazy przez ef, potem tworzymy tymczasowe zmienne dla hashu i soli danego usera, potem funkcję do generowania 
hasha ktora przyjmuje haslo podane w metodzie Register i tymczasowe zmienne hashu i soli jako referencje (out). Ta funkcja implementuje 
interfejs IDisposable, czyli po jej wykonaniu wszystko zostaje wrzucone do garbage collectora, wiec trzeba stworzyc blok 
using(var hmac = new HMACSHA512). w nim wyciagamy  hmac.Key (czyli sol wygenerowana przy stworzeniu obiektu hmac) jako passwordSalt, i 
uzywamy metody ComputeHash z haslem usera jako argumentem i wrzucamy do passwordHash. Potem powrot do metody Register, 
tam przypisujemy naszemu userowi sol i haslo = temp soli i hasle, potem uzywamy  naszego _context.Users.AddAsync(user) 
i _context.SaveChangesAsync(), zwracamy usera.

Logowanie - podobnie, stworzyc zmienna przechowujaca usera (var user = await _context.Users.FirstOrDefaultAsync(x => x.Username == username);) ktora
wyszukuje go w bazie, potem sprawdzic czy znalazlo, potem uruchomic i stworzyc metode ktora w podobny sposob co wyzej sprawdza czy hash sie zgadza 
przy konstruktorze hmac wrzucic sol z obiektu user, potem jesli sprawdzanie == false zwrocic nulla, jesli true zwrocic usera

Dodawanie authrepo do konfiguracji api - w funkcji ConfigureServices.AddScoped<IAuthRepository, AuthRepository>(); ta metoda tworzy repozytorium
za każdym razem kiedy nadchodzi request od klienta (czyli np się łączy, czyli jedna instancja na połączenie klienta)

Stworzenie AuthControllera - tu dużo rzeczy jest tymczasowe - stworzyc klase AuthController dziedziczaca po ControllerBase. W konstruktorze 
ma przyjmowac IAuthRepository które będzie zajmowac sie rejestracja i logowaniem od strony bazy, stworzyc async funkcje Register z TYMCZASOWO
string username i string password (potem to bedzie zserializowany json). Na poczatku kiedys bedzie validate request, potem trzeba zmienic username
na lowercase, sprawdzic czy taki user juz istnieje korzystajac z _repo, jesli nie zwrocic BadRequest, jesli nie istnieje stworzyc nowy obiekt User,
nadac mu user.Username = username, potem znowu wywolac funkcje Register z _repo, podajac usera i haslo. Na koncu TYMCZASOWO zwrocic statuscode(201)

DTO wstęp: dto to obiekt json ktory bedzie przesylany z angulara do api i bedzie zawierac dane usera. W api stworzyc folder dtos i klase UserForRegisterDto
z polem Username i Password. Potem w AuthController pozmieniac metode register tak zeby przyjmowala obiekt UserForRegisterDto a nie osobne pola.
Na samym poczatku metody register dodac punkt pauzy debuggera, stworzyc nowa konfiguracje debuggera, .NET Core, przy procesie do zaczepienia
wpisac "api" i dolaczyc do dotnet.exe ktory jest w folderze z api, potem wejsc do postmana, zrobic requesta post dla localhost:5000/api/auth/register,
w body dac raw i zmienic zawartosc na jsona , w nim dac { "username": "John", "password": "password" }, dzieki temu bedzie mozna sprawdzic czy 
metody do rejestracji dzialaja bez stworzenia frontendu do rejestracji. Po wyslaniu requesta debugger powinien zatrzymac kod i pokazac co sie
dzieje - rejestracja powinna pojsc ok, mozna potem sprawdzic w przegladarce sqlite. powinno zwrocic 201 created, przy drugim post dla takiego samego
hasla i username juz powinien zwrocic 400 bad request, przy pustym username i password powinno wciaz utworzyc, w kolejnym kroku poprawi sie to 
dzieki walidacji.

Validation requests w api: walidacja musi byc w miejscu gdzie są same dane wysłane przez usera, czyli login i hasło jako string, czyli UserForRegisterDto.
Nad deklaracja pola wystarczy dodać znaczek [Required], wtedy nie przejdzie empty string. przy haśle trzeba dodac Required i można dodać dodatkowe wymagania,
np StringLenhth od 4 do 8. Teraz w postmanie przy probie zarejestowania pustego usera wyskoczy error 400, dzieki temu ze AuthController ma atrybut [ApiController]
Po zakomentowaniu atrybutu po próbie zarejestrowania sie z empty stringami wyskoczy internal server 500, a konkretnie nullreferenceexception. Okazuje sie ze
username jest teraz nullem i konwersja na lowercase wywala wyjątek (można sprawdzic debuggerem). Gdyby [ApiController] nie bylo zakomentowane api "wywnioskowaloby"
że UserForRegisterDto pochodzi z strony i nie moze byc nullem. Mozna tez to osiagnac dodajac atrybut [FromBody] przed nazwa klasy (UserForRegisterDto) w metodzie Register
Bez ApiController trzeba zrobic walidacje (if (!modelState.IsValid) return BadRequest(ModelState);), wtedy dostaniemy juz bad request 400. Jednak najlepszą opcją
jest dodanie ApiController i usuniecie FromBody i walidacji przez ModelState.

Token authentication - zawiera 3 części - header z ingo o rodzaju szyfrowania i typie struktury (JWT, json web token), payload, czyli czesc przechowujaca informacje
np id, name. oprocz tego zawiera info tokenu, czyli date wygenerowania, date wygasniecia i date wejscia do uzycia. Te dwie czesci moga byc odczytane przez kazdego!
Ostatnia czesc to signature, czyli czesc ktora autoryzuje token. Tworzy sie go szyfrujac header i payload tokenu przy uzyciu sekretu jako soli (?). Sekret
jest trzymany na serwerze. Logowanie bedzie dzialalo tak że klient wysyla login i haslo, serwer odsyla token ktory klient zapisuje, a do kazdego kolejnego żądania 
klienta dołączany będzie token który potwierdza że user jest ok.

Tworzenie metody logowania: stworzyc UserForLoginDto ktore bedzie takie samo jak UserForRegisterDto ale bez obostrzeń, można przesłać wszystko, nawet puste. W AuthController
stworzyć metode login przyjmujaca UserForLoginDto. Najpierw musi sprawdzac czy taki user istnieje, korzystajac z _repo.Login i jesli userFromRepo bedzie nullem zwrocic
Unauthorized. Teraz celem funkcji jest wygenerowanie i wyslanie tokenu. Wszystkie jego czesci generuje sie klasami ktore potem laczy sie w jedno SecurityTokenDescriptior. 
Najpierw trzeba zrobić tablicę Claims zawierającą id i login, potem klucz. Klucz będzie trzymany w appsettings.json żeby mieć do niego dostęp z różnych części aplikacji,
więc dodajemy "AppSettings": { "Token": "dupa1234dupa1234" } (pamiętać że są dwa appsettings w zależności czy jesteśmy w trybie produkcyjnym czy deweloperskim), w konstruktorze
naszego AuthController dodajemy IConfiguration i pole _config żeby mieć dostęp do appsetings, pobieramy klucz do zmiennej i konwertujemy na byte[], tworzymy obiekt 
SigningCredentials podajac jako argumenty klucz i typ szyfrowania, potem tworzymy SecurityTokenDescriptior w ktorym Subject = claims, Expires = DataTime.Now.AddDays(cośtam) i 
SigningCredentials = creds. Na końcu tworzymy obiekt ktory tworzy jwt (JwtSecurityTokenHandler), tworzymy token uzywajac jego metody CreateToken z arugmentem tokenDescriptor
i zwracamy klientowi Ok(new {token = tokenHandler.WriteToken(token)})

Zmuszenie innych kontrolerów do autoryzacji - testowo użyjemy ValuesController - przed klasą dać znacznik [Authorize], dzieki temu kazda metoda z kontrolera bedzie wymagala 
logowania. Oczywiscie mozna zmusic jakas metode do zezwolenia na anonimowe logowanie, dajac przed metoda znacznik [AllowAnonymous]. Teraz trzeba poinformować api skąd ma brać
secret, jaka jest konfiguracja autoryzacji itd. W metodzie startup.cs w metodzie ConfigureServices dodać services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).
AddJwtBearer(options => {}). W wyr lambda przypisujemy TokenValidationParameters jako nowy obiekt TokenValidationParameters, i właśnie tam ustawiamy konkretne opcje. Pierwsza 
właściwość to ValidateIssuerSigningKey = true, która zaznacza że potrzebny jest secret key, drugi parametr to właśnie ten klucz i ścieżka do niego, czyli IssuersSigningKey =
new SymmetricSecurityKey(Configuration.GetSection(ścieżka do klucza w appsetings.json)), ostatnie to ValidateIssuer i ValidateAudience, oba na false, one służą do sprawdzenia
wystawcy tokena i odbiorcy tokena podczas sprawdzania tokena, póki co wszystko robimy na localhost więc damy na false. Na koncu w metodzie Configure przed UseMvc uruchamiamy 
app.UseAuthentication(). W postmanie przy metodzie get (!!!) na values/liczba powinno zwracac wartosc z bazy bo ustawilismy zeby pozwalalo anonimon, za to przy samo /api/values
juz nie bedzie dzialac. Zeby sie dostac do values trzeba sie zalogowac, wtedy dostaniemy token w body json, kopiujemy go i dodajemy nowy header z key Authorization i z value
Bearer tu_wstaw_token. Teraz values dziala.

Tworzenie formy do logowania - wejsc na getbootstrap i skopiować kod html z jakiegoś example np jumbotron (wszystko w <nav>), to będzie szkic naszej formy. Teraz robimy nowy
komponent "nav" w src/app (ppm/generate new component) i kopiujemy html z bootstrapa do nav.component.html Żeby aktywować nav w stronie głównej dołożyć do app.component.html 
na samym początku <app-nav>. Teraz zmienić navbar-brand na Dating App, wywalić button navbar toggler bo ono korzysta z jquery a my nie chcemy jquery, wywalić navbar collapse
Mają być 3 navlinki, Matches, Lists i Messages, wywalić navbar dropdown. Do tego dać 2 inputy dla loginu i hasła, zmienić submit na login i wywalić część "outline" w nazwie klasy.4
Na koniec wywalić fixed top z samej góry, teraz header będzie poniżej navbara.

Tworzenie formy do logownia - kazda forma html może byc zmieniona na forme angulara. Najpierw w nav.component robimy obiekt "model: any = {};", póki co pusty. Model będzie przetrzymywać
username i password z htmla. Robimy jeszcze funkcje login(), w niej console.log(model), tymczasowo, żeby sprawdzić czy wszystko działa ok.Teraz wracamy do nav.html i musimy oznaczyc 
ze forma html jest tez forma angulara, dodajac #loginForm="ngForm" w <>. Żeby aktywować ngForm w naszej apce  trzeba przejść do app.module i zaimportować: w sekcji imports dodac FormsModule, 
na samej gorze dodać import {FormsModule} from '@angular/forms'. Teraz w nav.html dodać  przy deklaracji kontrolki username i password a-ngModel, dać tab i aktywuje sie snippet. 
Zmienic binding na model.username, to samo dla hasla (model.password). Dla deklaracji  formy (nie przycisku submit) dodajemy ngSubmit)="login()", teraz klikniecie buttona 
aktywuje metode login() z pliku .ts Do inputow dodac znacznik "required" i name, bez name angular nie powiaze inputu html z modelem. Sprawdzic czy dziala. Jesli sie zalogujemy
z pustymi polami login i password wciaz bedzie proba logowania, mimo tego ze pola sa required, bo angular nie wie co zrobic jesli pola nie sa wypelnione. Zeby to zmienic dodac do
buttona w htmlu [disabled]=!loginForm.valid. Angular caly czas sprawdza kiedy forma jest "valid" i udostepnia takie parametry. Teraz kiedy zaznaczylismy że oba pola sa required valid
valid bedzie tylko wtedy kiedy w obu cos jest wpisane, parametr valid bedzie true, dzieki temu mozna wplywac na disabled.

Angular Service - specjalny obiekt angulara który służy do przekazywania i zapisywania danych pomiędzy częściami aplikacji które o sobie nic nie wiedzą, w tym wypadku do komunikacji 
a api. Dzięki niemu komponenty będą też odseparowane od siebie. W /src/app dodać folder _services i użyć ppm i wygenerować service auth (tylko plik .ts). @Injectable pozwala na 
wstrzykiwanie. providedIn wskazuje w którym module ma działać service, root = app.module. Trzeba też dodać info o service w app.module.ts - w providers dodac AuthService, dać tab
i vscode doda import. Teraz service może być wstrzykiwane do komponentów. W auth.service.ts dodać konstruktor z argumentem http: HttpClient (z angular/common/http, użyć tab).
Dodać zmienną baseUrl ze ścieżką do api/auth, doodać metode login ktora bedzie przyjmowala model : any (z navbaru), i ktora zwraca  
return this.http.post(this.baseUrl + 'login', model).pipe(
      map((response: any) => {
        const user = response;
       if (user) {
          localStorage.setItem('token', user.token);
        }
To powyżej wykonuje request http (post), przekazujac adres i cialo requestu czyli model z loginem i hasłem do logowania. Zajmujemy sie tez reakcja na http response, czyli plikiem json
Przez rxjs mapujemy odpowiedź do bloku kodu który zapisuje ją do zmiennej user, a następnie zapisuje do localStorage część pliku json która jest czystym tokenem.
Ten blok wykona się od razu po otrzymaniu odpowiedzi. Należy jeszcze zaimportować map z rxjs/operators

Injecting service in component: w konstruktorze nav.component dodać authService: AuthService (tab). Teraz przy metodzie login można użyc requestu http: this.authService.login(this.model)
(model to mode.username i model.password, zdefiniowane w pliku nav.component.html). Jako że service zwraca Observable, czyli czeka na odpowiedź od api, trzeba dodać 
.subscribe(next => {
      console.log('Logged in successfully!');
    }, error => {
      console.log('Failed to login!');
    });
Next to blok wykonywany jeśli subskrybowany Observable wykona się poprawnie, czyli jeśli dostaniemy odpowiedz od api. Error wykona sie jesli odpowiedzi nie dostaniemy. Sprawdzic czy dziala.
Po wejsciu w zakladke Network debuggera widzimy 2 wartosci login, pierwsza to cos w rodzaju headera, drugi to wysylane dane, mozna je zobaczyc w zakladce Headers. W Response widac zwrotny
plik json z tokenem ktory jest zapisywany do localStorage.

Conditional rendering Angular components - pobieramy z getbootstrap.com/docs/components/dropdown kod html, ten z <a>. Do nav.component.html wklejamy blok z bootstrapa. Teraz kosmetyka,
usunąć z dropdown-toggle btn i btn-secondary, zmienic nazwe na Welcome User, usunac wszystkie properties za id. Teraz usunac z wysuwanych linkow aria, zmienic nazwy na Edit Profile i Logout,
srodkowa zmienic na <div class="dropdown-divider"> Do dropdown-itemow dodac ikony (<i class="fa fa-user" albo fa-sign-out), dodac do dropdown-toggle text-light. Dalej nie da sie rozwinac
dropdown menu. 
Teraz dodajemy metody do sprawdzania czy user jest zalogowany - loggedIn tworzy zmienna const token = localstorage.getItem('token'), a nastepnie jest linijka !!token - to skrot od 
if(token != null) return true; else return false;, zapamiętać, ważne. Dodać też metode logout (localstorage.removeitem('token') + jakies info w konsoli). Teraz mozna wykoryzstac te metody w 
htmlu - blok z dropdownem powinien byc dostepny tylko dla zalogowanych userow, dodajemy wiec przy jego deklaracji a-ngIf, tab, zmienic expression na "loggedIn()". Teraz blok dropdown wykona
sie tylko wtedy jesli metoda z ngIf zwroci true. Blok z kontrolkami logowania (#loginForm) powinien byc za to rysowany jeśli user nie jest zalogowany, dodajemy wiec *ngIf="!loggedIn()" - teraz
musi byc zwrocone false zeby wszystko zadzialalo. Sprawdzic czy dziala, poki co dropdowna nie da sie rozwinac. Dodajmy jeszcze jakis tymczasowy przycisk do wylogowania - dodac nav-link pod
messages (Logout), dodac atrybut (click)="logout()", teraz po kliknieciu wykonuje sie funkcja logout, wszystko aktualizuje sie w czasie rzeczywistym bez odswiezania strony.

Adding Register components - dodać dwa komponenty - home z częścią "reklamową" strony i "register" z częścią rejestracji. Kurs dostarcza plik html ktory zawiera ładny layout komponentu w 
bootstrapie z dwoma zdaniami i dwoma przyciskami. Rzeczy bootstrapowe - mt-5 określa margines, mt=margin top, jest 6 opcji, czyli 5 to prawie najwiekszy odstep jaki da sie zrobic bootstrapem
Div do wyswietlania formy z rejestracja ma dopisek "col-4", co znaczy ze rzeczy wewnatrz divu beda sie wyswietlaly na 4 z 12 kolumn. W glownym htmlu aplikacji (app.component.html) zamiast h1 
dać <app-home>. Przy nazwie klasy buttonow dodac marginesy ("mr-2" albo "ml-2"). Do register.component.html tez wkleic szablon z kursu. W register.ts dodać model: any = {};, metody
register() i cancel(), póki co tylko z console.log. Teraz mówimy angularowi że to jest formularz - w register.component przy znaczniku <form> dodać #registerForm="ngForm" (ngSubmit) = "register()"
Przy polach username i password dodać znaczniki required, name="username" albo "password", snippet a-ngModel, tab i "model.username" albo "model.password". Przy buttonie cancel dodać (click)="cancel()"
Wrocic do home.component.html i w kontenerze na dole (tym z 4/12 kolumn) dodać <app-register>. Teraz mamy jednoczesnie rejestracje i wstep, a chcemy miec tylko jedno z dwoch. Zeby to zmienic 
wchodzimy do home.html i przy kontenerze z app-register dodajemy *ngIf="registerMode", a przy kontenerze z opisem (nie tym głównym bo inaczej zniknie wszystko, włącznie z rejestracją!) dodać 
*ngIf="!registerMode". Dodać jeszcze (click)="registerToggle()" przy przycisku register. Teraz w .ts dodac registerMode = false (domyślnie będzie opis a nie rejestracja), i funkcje registerToggle()
która zmienia registerMode = !registerMode. Teraz po kliknieciu na rejestracje opis znika, jednak nie da sie wrocic do trybu opisu. Dzieje sie to dlatego że przycisk cancel jest w app.register,
a metoda zmieniajaca registerMode w app.home, i póki co jedno nie umie odwoływać się do drugiego. W następnej sekcji to będzie poprawione.