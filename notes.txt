.net core sdk (cli, to z vs2019 to co innego)
node.js najnowsze lts, npm ważny
vscode
db browser for sqlite 
postman

baza danych -> orm (object relation mapping, obiekty c# tworzące się na podstawie danych z bazy) -> api (umożliwia dogadanie sie 
orm ze spa) -> spa(angular) -> przeglądarka

najprostsze możliwe przekazanie danych z bazy do przeglararki, potem stopniowa rozbudowa

typ projektu .net core - asp net core web api żeby 3 warstwy były maksymalnie niezależne
dodać -o lokalizacja -n nazwa

Rozszerzenia do vscode:
c# od ms
c# extensions do szybkiego tworzenia klas 
nuget package manager

Projekt c# - Program.cs = main i CreateWebHostServer (tworzy Kestrel web server)
	Startup.cs = konfiguracja web servera - env (developer environment czy PRODUKCJA, to drugie daje hsts czyli powiazanie z https)
	PÓKI CO zakomentować to z https, do tego dodaje do web servera mvc framework który przekierowuje requesty do odpowiedniego
	kontrolera
	value controller - przekierowanie do odpowiedniego kontrolera odbywa sie przez 

	ctrl + slash = komentowanie linii

	Dotarcie do strony którą obsługuje ten kontroler:  http://localhost:5000/api/values
    	localhost bo serwer jest tam gdzie klient, 5000 bo to port kestrela, api bo route linijka nizej, values bo bierze 
        pod uwage slowo przed slowem "controller"

	bloki z httpGet, HttpPut, HttpPost uruchamiają ten blok dla konkretnych requestów http o tych nazwach.

launchSettings.json - konfiguracja serwera kestrel, ustalanie portow itd
Ctrl+tylda = terminal, dotnet run
Domyślnie nie będzie działać bo trzeba otworzyć /api/values żeby serwer przetworzył jakieś żądanie

Konfiguracja typu debugowania itd - appsetings.json, appsetingsDevelopment.json
Zmiana trybu: launchSettings.json - ASPNETCORE_ENVIRONMENT
dotnet watch run - uruchamia serwer i restartuje go przy zmianach kodu

Tworzenie modelu, czyli klasy która przechowuje dane z bazy (Value.cs) - na początku bardzo prosty
prop + tab = autogenerowanie klasy
Entity Framework = łączenie modelu (entity, w tym wypadku klasa Value) z bazą - stworzenie klasy (DataContext.cs)
która to zrobi - nowa klasa dziedziczy po klasie DbContext
Ctrl+kropka = autosugestie!
ctor + tab = autogenerowanie konstruktora
Konstruktor musi mieć jako argument klasę DbContextOptions<DataContext> : base (options)
DataContext powinno zawierać klase DbSet<Value> która przetwarza zapytania linq na zapytania do bazy i tworzy bazę. 
Value to wcześniej utworzony model (entity). Nazwa obiektu to nazwa tabeli w bazie

Poinformowanie api o nowej bazie i klasie value - w Startup.cs w metodzie ConfigureServices dodajemy service adddbcontext,
w <> dodajemy nazwę klasy datacontext i przekazujemy w opcjach przez wyr lambda typ bazy, tutaj sqlite
Zainstalować sqlite - jeśli jest addon nuget - ctrl+shift+p, -> nuget add package -> Microsoft.EntityFrameworkCore.Sqlite
Connection string dodaje się w appsetings.json - dzięki temu można go wywołać w dowolnym miejscu i zawsze bedzie dostepny, nawet w 
developement mode, bo json developementa nadpisuje zwykly, jesli w zwyklym bedzie rzecz ktorej nie ma w develoepement to jej nie nadpisze
 "ConnectionStrings": {
    "DefaultConnection": "Data Source=DatingApp.db"
  },
wewnatrz 1 nawiasu wasatego w appsettings.json
dostanie sie do tego z c#: Startup.cs - Configuration.GetConnectionString("DefaultConnection") - znajduje sekcje o nazwie DefaultConnection

Tworzenie bazy: dotnet ef migrations add InitialCreate - to sprawdzi nasze dbcontext (które zawierają info o values), sprawdzi gdzie
chcemy zapisać bazę (Startup.cs - AddDbContext), wykryje które pole klasy to Id i da je jako primary key itd.
Migration tworzy PLAN przetworzenia danych z kodu do prawdziwej bazy danych
dotnet ef database update - aktualizuje plik z danych migracji (albo go tworzy jesli go nie ma)
Otworzyc baze przez Db Browser for SQLite i dodac kilka rekordow

ctrl+p = go to file
Powiązanie bazy z metodą httpget - wstrzyknięcie datacontext do metody przez utworzenie w klasie valuescontroller i prywatne pole
z DataContext
Potem w httpget zmiana na IActionResult i wewnątrz stworzenie zmiennej do której wrzuca się _context.Values.ToList() (DataContext
zawiera wszystkie potrzebne metody). Potem zwrócić klientowi wewnatrz response Ok (czyli Ok(values))
HttpGet("{id}") podobnie, tylko w metodzie GetValue przekazac int id, a potem zeby sprwadzic ktora to zmienna uzyc wyrazenia lambda
var value = _context.Values.FirstOrDefault(x => x.Id == id);

Otworzyc postmana, sprawdzic czy wszystko jest ok "http://localhost:5000/api/values", można dodać potem "/3" itd, jesli przekroczymy
ilosc rekordow w bazie to zwroci pusta strone i status 204 no context bo uzylismy metody FirstOrDefault zeby nie wywaliło wyjątku

Http requesty asynchronicznie: zmienic metode ktora uruchamia request na async Task<IActionResult>. Teraz metoda bedzie zwracac 
asynchroniczne zadanie. Przy miejscu które może trwać dużo czasu i chcemy żeby nie blokowało całego programu dodajemy await,
dodatkowo trzeba zmienic metode przy await na asynchroniczna (ToListAsync). Każdy request powinien być async

Zainstalować angular cli przez npm, użyłem wersji 6.2.9 lts, stworzyć projekt przez ng new DatingApp-SPA

Użyte moduły i ich wersje są opisane w package.json, główny folder aplikacji Angulara to src/app. Angular ma komponenty, czyli coś
w rodzaju klas z powiązaniami. Domyślnie w pliku index.html uruchamiany jest komponent z selectorem "app-root", czyli ten w 
domyślnym pliku app.component.ts. app.module.ts to plik z modułem, czyli czymś co ładuje poszczególne komponenty.
Moduł jest ładowany bezpośrednio w pliku main.ts. w nim jeszcze jest info że aplikacja jest pod przeglądarkę (platformBrowserDynamic)
i że chcemy uzywac bootstrapa w module (bootstrapModule(AppModule)), co włacza tez bootstrapa na każdy komponent uruchamiany przez moduł
main.ts jest uruchamiany mimo że w index.html nie ma zadnej informacji o nim dzieki webpackowi w angularze, ktory pakuje wszystko do js
i wstrzykuje do htmla w trakcie kompilacji (?).
Uruchomic projekt angulara (ng serve), bedzie sluchac na porcie 4200

Dodac kilka rozszerzen do vscode dla angulara: Angular v7 Snippets, Angular Files do szybkiego tworzenia plkikow, ANgular Language 
Service (goto definition), Angular2-switcher do szybkiego przełączania pomiedzy plikami ts, html i css, auto rename tag, bracket pair
colorizer, debugger for chrome, path intellisense, prettier do autoformatu, tslint do podkreślania.

Tworzenie http requestów w angularze: stworzyć komponent (ppm i create component, value wtedy zrobi folder z wszystkimi potrzebnymi
plikami). Dodało też w pliku app.module informacje że korzystamy z komponentu value. 
Klasy do requestów są w pliku angular/common/http, trzeba zaimportować je w app.module.ts. Potem w value.component.ts 
tworzymy pole values:any, które będą przechowywać dane z serwera aspnet i metodę getValues, która korzysta z httpclienta angulara
i robi request na localhost:500/api/values, a potem subskrybuje, czyli zapisuje odpowiedź do values: 
getValues() {
    this.http.get('http://localhost:5000/api/values').subscribe(response => {
      this.values = response;
    }, error => {
      console.log(error);
    });
Dodać jeszcze wywołanie metody getValues w ngOnInit, czyli metodzie wywołującej się po załadowaniu komponentu
Alt+O = przejście do http danego komponentu, Alt+U = przejście do ts danego komponentu
W stronie tytułowej angulara (app.component.html) dodać znacznik <app-value>, który uruchomi komponent value (nie będzie go widać na stronie
bo nie ma backendu, ale można go zobaczyć w konsoli). W konsoli jest info o Access-Control-Allow-Origin blocked blabla, trzeba to poprawic i dodac cors

CORS pozwala na ustalenie którzy klienci mogą mieć dostęp do naszego api (np wywołanie localhost:5000 z localhost:4200). Zeby to zrobic
najpierw w metodzie configureServies trzeba dodać Cors (services.AddCors()), a potem go ustalić na co ma pozwalać (w metodzie configure
dodać app.UseCors(x => x.AllowAnyOrigin().AllowAnyMethod().AllowAnyHeader());, to pozwala na wszystko wszystkim, później to się zmieni

Wyświetlenie wartości na stronie, a nie w konsoli chroma: w value.component.html przy znaczniku p dodać pętlę angulara która pozwala na wrzucanie elementow na strone:
<p *ngFor="let value of values">
  {{value.id}}, {{value.name}}
</p>
values to var do którego przesyłane są dane z api, mozna sie dostac do poszczegolnych id i name, sukces XD

Bootstrap i FontAwesome: npm install bootstrap font-awesome
potem w głównym pliku css zaimportować bootstrap.min.css a potem font-awesome.min.css, potem w htmlu componenta można usunąć znacznik style

git: wywalic .git z spa, dodac gitignore dla api, zrobic git init w głównym folerze aplikacji, stworzyć repo na githubie, zrobić remote
add origin [adres], potem pierwszy commit i push to 

dodanie modelu usera: stworzyc klase z id, loginem, hashem hasla i solą (oba to byte[]), dodac info o tej klasie w datacontext, zrobic kolejna
migracje, potem dac dotnet ef database update

Repository interface - kolejna warstwa abstrakcji ktora jest interfejsem. Zawiera szkielet wszystkich metod ktore beda potrzebne api do 
wykonania jego metod, i kazda klasa ktora bedzie pobierac dane z bazy musi implementowac ten interfejs, dzieki czemu api bedzie po czesci 
niezalezne od frameworków.

Stworzenie interfejsu: w folderze data stworzyc interfejs IAuthRepository, zrobic 3 taski (metody async), login ktory przyjmuje nazwe usera, 
haslo a zwraca obiekt user (w jaki sposob ten user zostanie stworzony to juz kwestia konkretnego AuthRepository), register który zwraca usera
i przyjmuje usera i password, i UserExists ktory przyjmuje string username a zwraca boola. 

Rejestracja - najpierw tworzymy klase AuthRepository ktora implementuje interfejs IAuthRepository, w konstruktorze będzie DataContext dzięki
któremu bedzie mozna przesylac dane do bazy przez ef, potem tworzymy tymczasowe zmienne dla hashu i soli danego usera, potem funkcję do generowania 
hasha ktora przyjmuje haslo podane w metodzie Register i tymczasowe zmienne hashu i soli jako referencje (out). Ta funkcja implementuje 
interfejs IDisposable, czyli po jej wykonaniu wszystko zostaje wrzucone do garbage collectora, wiec trzeba stworzyc blok 
using(var hmac = new HMACSHA512). w nim wyciagamy  hmac.Key (czyli sol wygenerowana przy stworzeniu obiektu hmac) jako passwordSalt, i 
uzywamy metody ComputeHash z haslem usera jako argumentem i wrzucamy do passwordHash. Potem powrot do metody Register, 
tam przypisujemy naszemu userowi sol i haslo = temp soli i hasle, potem uzywamy  naszego _context.Users.AddAsync(user) 
i _context.SaveChangesAsync(), zwracamy usera.

Logowanie - podobnie, stworzyc zmienna przechowujaca usera (var user = await _context.Users.FirstOrDefaultAsync(x => x.Username == username);) ktora
wyszukuje go w bazie, potem sprawdzic czy znalazlo, potem uruchomic i stworzyc metode ktora w podobny sposob co wyzej sprawdza czy hash sie zgadza 
przy konstruktorze hmac wrzucic sol z obiektu user, potem jesli sprawdzanie == false zwrocic nulla, jesli true zwrocic usera

Dodawanie authrepo do konfiguracji api - w funkcji ConfigureServices.AddScoped<IAuthRepository, AuthRepository>(); ta metoda tworzy repozytorium
za każdym razem kiedy nadchodzi request od klienta (czyli np się łączy, czyli jedna instancja na połączenie klienta)

Stworzenie AuthControllera - tu dużo rzeczy jest tymczasowe - stworzyc klase AuthController dziedziczaca po ControllerBase. W konstruktorze 
ma przyjmowac IAuthRepository które będzie zajmowac sie rejestracja i logowaniem od strony bazy, stworzyc async funkcje Register z TYMCZASOWO
string username i string password (potem to bedzie zserializowany json). Na poczatku kiedys bedzie validate request, potem trzeba zmienic username
na lowercase, sprawdzic czy taki user juz istnieje korzystajac z _repo, jesli nie zwrocic BadRequest, jesli nie istnieje stworzyc nowy obiekt User,
nadac mu user.Username = username, potem znowu wywolac funkcje Register z _repo, podajac usera i haslo. Na koncu TYMCZASOWO zwrocic statuscode(201)

DTO wstęp: dto to obiekt json ktory bedzie przesylany z angulara do api i bedzie zawierac dane usera. W api stworzyc folder dtos i klase UserForRegisterDto
z polem Username i Password. Potem w AuthController pozmieniac metode register tak zeby przyjmowala obiekt UserForRegisterDto a nie osobne pola.
Na samym poczatku metody register dodac punkt pauzy debuggera, stworzyc nowa konfiguracje debuggera, .NET Core, przy procesie do zaczepienia
wpisac "api" i dolaczyc do dotnet.exe ktory jest w folderze z api, potem wejsc do postmana, zrobic requesta post dla localhost:5000/api/auth/register,
w body dac raw i zmienic zawartosc na jsona , w nim dac { "username": "John", "password": "password" }, dzieki temu bedzie mozna sprawdzic czy 
metody do rejestracji dzialaja bez stworzenia frontendu do rejestracji. Po wyslaniu requesta debugger powinien zatrzymac kod i pokazac co sie
dzieje - rejestracja powinna pojsc ok, mozna potem sprawdzic w przegladarce sqlite. powinno zwrocic 201 created, przy drugim post dla takiego samego
hasla i username juz powinien zwrocic 400 bad request, przy pustym username i password powinno wciaz utworzyc, w kolejnym kroku poprawi sie to 
dzieki walidacji.

Validation requests w api: walidacja musi byc w miejscu gdzie są same dane wysłane przez usera, czyli login i hasło jako string, czyli UserForRegisterDto.
Nad deklaracja pola wystarczy dodać znaczek [Required], wtedy nie przejdzie empty string. przy haśle trzeba dodac Required i można dodać dodatkowe wymagania,
np StringLenhth od 4 do 8. Teraz w postmanie przy probie zarejestowania pustego usera wyskoczy error 400, dzieki temu ze AuthController ma atrybut [ApiController]
Po zakomentowaniu atrybutu po próbie zarejestrowania sie z empty stringami wyskoczy internal server 500, a konkretnie nullreferenceexception. Okazuje sie ze
username jest teraz nullem i konwersja na lowercase wywala wyjątek (można sprawdzic debuggerem). Gdyby [ApiController] nie bylo zakomentowane api "wywnioskowaloby"
że UserForRegisterDto pochodzi z strony i nie moze byc nullem. Mozna tez to osiagnac dodajac atrybut [FromBody] przed nazwa klasy (UserForRegisterDto) w metodzie Register
Bez ApiController trzeba zrobic walidacje (if (!modelState.IsValid) return BadRequest(ModelState);), wtedy dostaniemy juz bad request 400. Jednak najlepszą opcją
jest dodanie ApiController i usuniecie FromBody i walidacji przez ModelState.

Token authentication - zawiera 3 części - header z ingo o rodzaju szyfrowania i typie struktury (JWT, json web token), payload, czyli czesc przechowujaca informacje
np id, name. oprocz tego zawiera info tokenu, czyli date wygenerowania, date wygasniecia i date wejscia do uzycia. Te dwie czesci moga byc odczytane przez kazdego!
Ostatnia czesc to signature, czyli czesc ktora autoryzuje token. Tworzy sie go szyfrujac header i payload tokenu przy uzyciu sekretu jako soli (?). Sekret
jest trzymany na serwerze. Logowanie bedzie dzialalo tak że klient wysyla login i haslo, serwer odsyla token ktory klient zapisuje, a do kazdego kolejnego żądania 
klienta dołączany będzie token który potwierdza że user jest ok.

Tworzenie metody logowania: stworzyc UserForLoginDto ktore bedzie takie samo jak UserForRegisterDto ale bez obostrzeń, można przesłać wszystko, nawet puste. W AuthController
stworzyć metode login przyjmujaca UserForLoginDto. Najpierw musi sprawdzac czy taki user istnieje, korzystajac z _repo.Login i jesli userFromRepo bedzie nullem zwrocic
Unauthorized. Teraz celem funkcji jest wygenerowanie i wyslanie tokenu. Wszystkie jego czesci generuje sie klasami ktore potem laczy sie w jedno SecurityTokenDescriptior. 
Najpierw trzeba zrobić tablicę Claims zawierającą id i login, potem klucz. Klucz będzie trzymany w appsettings.json żeby mieć do niego dostęp z różnych części aplikacji,
więc dodajemy "AppSettings": { "Token": "dupa1234dupa1234" } (pamiętać że są dwa appsettings w zależności czy jesteśmy w trybie produkcyjnym czy deweloperskim), w konstruktorze
naszego AuthController dodajemy IConfiguration i pole _config żeby mieć dostęp do appsetings, pobieramy klucz do zmiennej i konwertujemy na byte[], tworzymy obiekt 
SigningCredentials podajac jako argumenty klucz i typ szyfrowania, potem tworzymy SecurityTokenDescriptior w ktorym Subject = claims, Expires = DataTime.Now.AddDays(cośtam) i 
SigningCredentials = creds. Na końcu tworzymy obiekt ktory tworzy jwt (JwtSecurityTokenHandler), tworzymy token uzywajac jego metody CreateToken z arugmentem tokenDescriptor
i zwracamy klientowi Ok(new {token = tokenHandler.WriteToken(token)})

Zmuszenie innych kontrolerów do autoryzacji - testowo użyjemy ValuesController - przed klasą dać znacznik [Authorize], dzieki temu kazda metoda z kontrolera bedzie wymagala 
logowania. Oczywiscie mozna zmusic jakas metode do zezwolenia na anonimowe logowanie, dajac przed metoda znacznik [AllowAnonymous]. Teraz trzeba poinformować api skąd ma brać
secret, jaka jest konfiguracja autoryzacji itd. W metodzie startup.cs w metodzie ConfigureServices dodać services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme).
AddJwtBearer(options => {}). W wyr lambda przypisujemy TokenValidationParameters jako nowy obiekt TokenValidationParameters, i właśnie tam ustawiamy konkretne opcje. Pierwsza 
właściwość to ValidateIssuerSigningKey = true, która zaznacza że potrzebny jest secret key, drugi parametr to właśnie ten klucz i ścieżka do niego, czyli IssuersSigningKey =
new SymmetricSecurityKey(Configuration.GetSection(ścieżka do klucza w appsetings.json)), ostatnie to ValidateIssuer i ValidateAudience, oba na false, one służą do sprawdzenia
wystawcy tokena i odbiorcy tokena podczas sprawdzania tokena, póki co wszystko robimy na localhost więc damy na false. Na koncu w metodzie Configure przed UseMvc uruchamiamy 
app.UseAuthentication(). W postmanie przy metodzie get (!!!) na values/liczba powinno zwracac wartosc z bazy bo ustawilismy zeby pozwalalo anonimon, za to przy samo /api/values
juz nie bedzie dzialac. Zeby sie dostac do values trzeba sie zalogowac, wtedy dostaniemy token w body json, kopiujemy go i dodajemy nowy header z key Authorization i z value
Bearer tu_wstaw_token. Teraz values dziala.

Tworzenie formy do logowania - wejsc na getbootstrap i skopiować kod html z jakiegoś example np jumbotron (wszystko w <nav>), to będzie szkic naszej formy. Teraz robimy nowy
komponent "nav" w src/app (ppm/generate new component) i kopiujemy html z bootstrapa do nav.component.html Żeby aktywować nav w stronie głównej dołożyć do app.component.html 
na samym początku <app-nav>. Teraz zmienić navbar-brand na Dating App, wywalić button navbar toggler bo ono korzysta z jquery a my nie chcemy jquery, wywalić navbar collapse
Mają być 3 navlinki, Matches, Lists i Messages, wywalić navbar dropdown. Do tego dać 2 inputy dla loginu i hasła, zmienić submit na login i wywalić część "outline" w nazwie klasy.4
Na koniec wywalić fixed top z samej góry, teraz header będzie poniżej navbara.

Tworzenie formy do logownia - kazda forma html może byc zmieniona na forme angulara. Najpierw w nav.component robimy obiekt "model: any = {};", póki co pusty. Model będzie przetrzymywać
username i password z htmla. Robimy jeszcze funkcje login(), w niej console.log(model), tymczasowo, żeby sprawdzić czy wszystko działa ok.Teraz wracamy do nav.html i musimy oznaczyc 
ze forma html jest tez forma angulara, dodajac #loginForm="ngForm" w <>. Żeby aktywować ngForm w naszej apce  trzeba przejść do app.module i zaimportować: w sekcji imports dodac FormsModule, 
na samej gorze dodać import {FormsModule} from '@angular/forms'. Teraz w nav.html dodać  przy deklaracji kontrolki username i password a-ngModel, dać tab i aktywuje sie snippet. 
Zmienic binding na model.username, to samo dla hasla (model.password). Dla deklaracji  formy (nie przycisku submit) dodajemy ngSubmit)="login()", teraz klikniecie buttona 
aktywuje metode login() z pliku .ts Do inputow dodac znacznik "required" i name, bez name angular nie powiaze inputu html z modelem. Sprawdzic czy dziala. Jesli sie zalogujemy
z pustymi polami login i password wciaz bedzie proba logowania, mimo tego ze pola sa required, bo angular nie wie co zrobic jesli pola nie sa wypelnione. Zeby to zmienic dodac do
buttona w htmlu [disabled]=!loginForm.valid. Angular caly czas sprawdza kiedy forma jest "valid" i udostepnia takie parametry. Teraz kiedy zaznaczylismy że oba pola sa required valid
valid bedzie tylko wtedy kiedy w obu cos jest wpisane, parametr valid bedzie true, dzieki temu mozna wplywac na disabled.

Angular Service - specjalny obiekt angulara który służy do przekazywania i zapisywania danych pomiędzy częściami aplikacji które o sobie nic nie wiedzą, w tym wypadku do komunikacji 
a api. Dzięki niemu komponenty będą też odseparowane od siebie. W /src/app dodać folder _services i użyć ppm i wygenerować service auth (tylko plik .ts). @Injectable pozwala na 
wstrzykiwanie. providedIn wskazuje w którym module ma działać service, root = app.module. Trzeba też dodać info o service w app.module.ts - w providers dodac AuthService, dać tab
i vscode doda import. Teraz service może być wstrzykiwane do komponentów. W auth.service.ts dodać konstruktor z argumentem http: HttpClient (z angular/common/http, użyć tab).
Dodać zmienną baseUrl ze ścieżką do api/auth, doodać metode login ktora bedzie przyjmowala model : any (z navbaru), i ktora zwraca  
return this.http.post(this.baseUrl + 'login', model).pipe(
      map((response: any) => {
        const user = response;
       if (user) {
          localStorage.setItem('token', user.token);
        }
To powyżej wykonuje request http (post), przekazujac adres i cialo requestu czyli model z loginem i hasłem do logowania. Zajmujemy sie tez reakcja na http response, czyli plikiem json
Przez rxjs mapujemy odpowiedź do bloku kodu który zapisuje ją do zmiennej user, a następnie zapisuje do localStorage część pliku json która jest czystym tokenem.
Ten blok wykona się od razu po otrzymaniu odpowiedzi. Należy jeszcze zaimportować map z rxjs/operators

Injecting service in component: w konstruktorze nav.component dodać authService: AuthService (tab). Teraz przy metodzie login można użyc requestu http: this.authService.login(this.model)
(model to mode.username i model.password, zdefiniowane w pliku nav.component.html). Jako że service zwraca Observable, czyli czeka na odpowiedź od api, trzeba dodać 
.subscribe(next => {
      console.log('Logged in successfully!');
    }, error => {
      console.log('Failed to login!');
    });
Next to blok wykonywany jeśli subskrybowany Observable wykona się poprawnie, czyli jeśli dostaniemy odpowiedz od api. Error wykona sie jesli odpowiedzi nie dostaniemy. Sprawdzic czy dziala.
Po wejsciu w zakladke Network debuggera widzimy 2 wartosci login, pierwsza to cos w rodzaju headera, drugi to wysylane dane, mozna je zobaczyc w zakladce Headers. W Response widac zwrotny
plik json z tokenem ktory jest zapisywany do localStorage.

Conditional rendering Angular components - pobieramy z getbootstrap.com/docs/components/dropdown kod html, ten z <a>. Do nav.component.html wklejamy blok z bootstrapa. Teraz kosmetyka,
usunąć z dropdown-toggle btn i btn-secondary, zmienic nazwe na Welcome User, usunac wszystkie properties za id. Teraz usunac z wysuwanych linkow aria, zmienic nazwy na Edit Profile i Logout,
srodkowa zmienic na <div class="dropdown-divider"> Do dropdown-itemow dodac ikony (<i class="fa fa-user" albo fa-sign-out), dodac do dropdown-toggle text-light. Dalej nie da sie rozwinac
dropdown menu. 
Teraz dodajemy metody do sprawdzania czy user jest zalogowany - loggedIn tworzy zmienna const token = localstorage.getItem('token'), a nastepnie jest linijka !!token - to skrot od 
if(token != null) return true; else return false;, zapamiętać, ważne. Dodać też metode logout (localstorage.removeitem('token') + jakies info w konsoli). Teraz mozna wykoryzstac te metody w 
htmlu - blok z dropdownem powinien byc dostepny tylko dla zalogowanych userow, dodajemy wiec przy jego deklaracji a-ngIf, tab, zmienic expression na "loggedIn()". Teraz blok dropdown wykona
sie tylko wtedy jesli metoda z ngIf zwroci true. Blok z kontrolkami logowania (#loginForm) powinien byc za to rysowany jeśli user nie jest zalogowany, dodajemy wiec *ngIf="!loggedIn()" - teraz
musi byc zwrocone false zeby wszystko zadzialalo. Sprawdzic czy dziala, poki co dropdowna nie da sie rozwinac. Dodajmy jeszcze jakis tymczasowy przycisk do wylogowania - dodac nav-link pod
messages (Logout), dodac atrybut (click)="logout()", teraz po kliknieciu wykonuje sie funkcja logout, wszystko aktualizuje sie w czasie rzeczywistym bez odswiezania strony.

Adding Register components - dodać dwa komponenty - home z częścią "reklamową" strony i "register" z częścią rejestracji. Kurs dostarcza plik html ktory zawiera ładny layout komponentu w 
bootstrapie z dwoma zdaniami i dwoma przyciskami. Rzeczy bootstrapowe - mt-5 określa margines, mt=margin top, jest 6 opcji, czyli 5 to prawie najwiekszy odstep jaki da sie zrobic bootstrapem
Div do wyswietlania formy z rejestracja ma dopisek "col-4", co znaczy ze rzeczy wewnatrz divu beda sie wyswietlaly na 4 z 12 kolumn. W glownym htmlu aplikacji (app.component.html) zamiast h1 
dać <app-home>. Przy nazwie klasy buttonow dodac marginesy ("mr-2" albo "ml-2"). Do register.component.html tez wkleic szablon z kursu. W register.ts dodać model: any = {};, metody
register() i cancel(), póki co tylko z console.log. Teraz mówimy angularowi że to jest formularz - w register.component przy znaczniku <form> dodać #registerForm="ngForm" (ngSubmit) = "register()"
Przy polach username i password dodać znaczniki required, name="username" albo "password", snippet a-ngModel, tab i "model.username" albo "model.password". Przy buttonie cancel dodać (click)="cancel()"
Wrocic do home.component.html i w kontenerze na dole (tym z 4/12 kolumn) dodać <app-register>. Teraz mamy jednoczesnie rejestracje i wstep, a chcemy miec tylko jedno z dwoch. Zeby to zmienic 
wchodzimy do home.html i przy kontenerze z app-register dodajemy *ngIf="registerMode", a przy kontenerze z opisem (nie tym głównym bo inaczej zniknie wszystko, włącznie z rejestracją!) dodać 
*ngIf="!registerMode". Dodać jeszcze (click)="registerToggle()" przy przycisku register. Teraz w .ts dodac registerMode = false (domyślnie będzie opis a nie rejestracja), i funkcje registerToggle()
która zmienia registerMode = !registerMode. Teraz po kliknieciu na rejestracje opis znika, jednak nie da sie wrocic do trybu opisu. Dzieje sie to dlatego że przycisk cancel jest w app.register,
a metoda zmieniajaca registerMode w app.home, i póki co jedno nie umie odwoływać się do drugiego. W następnej sekcji to będzie poprawione.

Parent to child communication - bedziemy przekazywac wartosci z home.component do register.component . Na potrzeby przykladu musimy przeslac jakies dane, a w home takich nie ma, pobierzemy wiec je
z api (te testowe wartosci z bazy danych) - na poczatek w ValuesController.cs w API przy metodzie [HttpGet("{id"})] i zwyklym HttpGet dodajemy znacznik [AllowAnonymous] żeby móc łatwo przesłać dane
bez bawienia sie w tokeny (potem to sie usunie), Teraz values.controller powinien dzialac i pokazywac wartosci (wczesniej byl zaimplementowany w app.component, ale w konsoli byl blad 401 unauthorized)
Teraz skopiowac do home.ts metode getValues z value.component i dodac w kontruktorze httpClient i prop values: any i w kontruktorze uruchomic metode getValues. Docelowo bedziemy chcieli zastapic value
app.component, usuwamy wiec caly folder value i importy z value w app.module. Dodac w home.html <p> z ngFor let value of values a wewnatrz {{value.name}}, w app.html wywalic app-value. Sprawdzic czy
dziala, usunąć <p>, była testowo żeby sprawdzic czy pobiera wartosci z serwera. Teraz chcemy przerzucic values z home do register. Robi sie to dodajac do deklaracji <app-register znacznik
[valuesFromHome]="values". To pierwsze to nazwa prop wewnatrz register.ts, a to drugie to nazwa propa wewnatrz home.ts. W register.ts dodajemy linijke @Input() valuesFromHome: any;, dziala jak zwykla 
deklaracja zmiennej ale ze znacznikiem ze jest z inputu. Teraz zeby sprawdzic czy dziala to w praktyce dodajemy w register.html div form-group, wewnatrz niego label z info i select form-control a w 
nim option z ngFor value of valuesFromHome [value]="value">{{value.name}}. Teraz w stronie powinien byc selector z nazwami values.

Child to parent comunication - tu zrobimy cos co rzeczywiscie przyda sie w aplikacji, przycisk cancel w register.component zmieni wartosc home.component i w efekcie usunie część html z rejestracja i
przywroci tą ze wstępem. Do register.ts dodać @Output() cancelRegister = new EventEmitter(); (emitter z angular/core). Przekazywanie do rodzica dziala na zasadzie emitowania eventów, których nasłuchuje
rodzic. Event może zawierać dowolny obiekt. Teraz dodajemy do metody cancel() this.cancelRegister.emit(false). W ten sposób emitujemy wczesniej utworzony Event zawierając w nim boolean false, które 
przyjmie rodzic i zmieni za jego pomocą registerMode, który wczesniej ustawilismy tez na boolean. W home.html przy deklaracji app-register dodajemy znacznik (cancelRegister)="cancelRegisterMode($event)"
To pierwsze jest znacznikiem eventu (?), mało ważne, a drugie to nazwa metody w home.ts. $event to znacznik że w środku będzie event, w tym wypadku to tylko false. Dodac w ohme.ts metode 
cancelRegisterMode(registerMode: boolean), ktora bedzie zmieniala this.registerMode na registerMode przekazany z register.component. Mozna tez zauwazyc ze metoda registerToggle bedzie wywolana tylko raz
i zmieni wartosc na true, wiec zeby nie dawac programowi szansy na dziwne błędy zmienmy !registerMode na true.

Adding register method - otworzyc auth.service.ts, dodać metode register(model:any). Ona zwraca tylko http.post do "api/register" przekazujacy model. Całą resztą zajmie sie api i ef. Metoda ta zwroci jednak
Observable, musimy wiec pamietac zeby ja zasubskrybować przy wywolaniu. W register.ts w konstruktorze dodajemy authService i w metodzie register() wywolujemy this.authService.register(this.model).subscribe
(() => {console.log('registration successful!');}, error => {console.log(error);}). W wypadku sukcesu ( czyli (), to skrót (chyba) a i tak nie bedziemy korzystac z metody success) podac console.log o sukcesie,
w wypadku error podobnie. Dodac przykladowego usera w stronie, sprawdzic czy dodal sie do bazy. Sprawdzic co sie stanie jesli dodamy drugi raz tego samego usera i jaki bedzie naglowek errora, sprawdzic co sie 
stanie jesli ustawimy za krotkie haslo. Te bledy w nastepnej sekcji beda wyswietlane na stronie a nie w konsoli. Usunac z projektu czesc kodu do z wywolywaniem values w rejestracji (@Input).

Error handling - żeby sprwadzic jak dziala zarzadzanie wyjatkami w asp .net core dodac na poczatku metody Login() throw new Exception("testowy wyjatek"). Teraz próbując dostac sie do api/auth/login w postmanie
dostajemy 500 error z developer exception page, zawierającą wszystkie informacje o wyjątku. Próbując się zalogowac z poziomu angulara dostajemy 500 internal server error i failed to load login, no access-control
-allow-origin. Dzieje sie tak bo api próbuje przesłać exception page, która nie zawiera cors http headera i w efekcie klient nie zezwala na dostęp (albo odwrotnie(?)). Nie da sie ich dodac, wiec zignorujmy drugi
błąd. Exception page wyświetla sie bo jestesmy w trybie dewelopera, zmieniając w properties/launchSettings.json ASPNETCORE_ENVIRONMENT na Production i probujac sie zalogowac w postmanie dostajemy 500 internal error
bez zadnych informacji. Jedyna mozliwosc na uzyskanie informacji o bledzie to terminal serwera. Dając całą metodę login w bloku try catch, gdzie przy catch zwracany jest StatusCode(500, "cośtam") w postmanie w body
będzie wiadomość z "cośtam", jednak wkładanie całej funkcji do try catch nie jest dobrym pomysłem, dodamy wiec global exception handler.

Global exception handler, api - w Startup.cs w metodzie Configure w else (czyli wtedy kiedy jestesmy w trybie produkcji) dać:
 app.UseExceptionHandler(builder => {
                    builder.Run(async context => {
                        context.Response.StatusCode = (int)HttpStatusCode.InternalServerError;

                        var error = context.Features.Get<IExceptionHandlerFeature>();
                        if(error != null)
                        {
                            await context.Response.WriteAsync(error.Error.Message);
                        }
                    });
                });
Ta część konfiguruje exception handler - każe mu wysyłać do klienta zawsze 500 InternalServerError (nawet jesli api ma zwracac inne errory, np unauthorized itd). Pozniej pobiera z wnętrza api error i jesli ten istnieje
dołącza wiadomość dołączoną do errora do responsa, a na samym końcu wysyła response. Zmienić na production mode, wysłać request w postmanie, teraz dostajemy w body message. Jednak w angularze dalej widzimy te same błędy,
bo dalej nie ma corsa. W głównym katalogu api tworzymy nowy folder Helpers, tworzymy statyczna klasę Extensions.cs. Tworzymy metode AddApplicationError(this HttpResponse, string message). W srodku dodajemy dodatkowe headery:
            response.Headers.Add("Application-Error", message);
            response.Headers.Add("Access-Control-Expose-Headers", "Application-Error");
            response.Headers.Add("Access-Control-Allow-Origin", "*");

))
Po dodaniu tego extension do response będzie ono miało 3 headery, pierwszy to error, dwa kolejne to headery ctor które pozwalają na wyświetlanie tej odpowiedzi po stronie klienta. Teraz musimy dodac headery do response:
przed wyslaniem dodajemy linijke context.Response.AddApplicationError(error.Error.Message); To wywoła statyczna funkcje ktora napisalismy chwile wczesniej. Sprawdzic czy dziala w postmanie, w headerach są nasze headery,
w kliencie jest już błąd "Failed to login".

Handling errors, angular - api musi byc caly czas w trybie production! Errory ktore dostajemy od api w konsoli wyswietlaja sie w calosci, a chcemy zeby przetwarzalo tylko messages. Tworzymy nową service error.intercepter.ts
ustawiamy ją jako @Injectable, tworzymy klasę (export class) ErrorInterceptor implements HttpInterceptor. Implementujemy interfejs, wiec musimy stworzyc metode intercept(). Przyjmuje ona req: HttpReqiest<any>, next: HttpHandler)
: Ovservable<HttpEvent><any>>. Po wywolaniu przechwytuje ona requesty i obsługuje je w skonfigurowany w kodzie sposob, szukajac bledow, czyli obiektow HttpErrorResponse. Pamietając że nasz header z errorem nazywa sie
'Application-Error', szukamy wlasnie takiego headera, jesli ten istnieje wrzucamy go do konsoli i zwracamy throwError. Dodajemy jeszcze warunek że jeśli error.status jest 401, to wtedy zwracamy throwError(error.statusText), żeby
przy 401 nie pokazywały się złe informacje. Musimy jeszcze stworzyc interceptor provider - ErrorInterceptorProvicer konfigurujący przechwytywanie requestow http. Dodajemy mu wlasciwosc privide: HTTP_INTERCEPTORS, ktora dodaje 
nasz ErrorInterceptor do angularowej tablicy interceptorów, useClass: ErrorInterceptor mówiący jaką klasę dodajemy do tablicy, oraz multi:true zaznaczjacy ze nie chcemy zastapic poprzednich interceptorow tylko dodac nasz do poprzednich
Teraz w app.module.ts dodajemy w providers ErrorInterceptorProvider i zapimportujemy ErrorInterceptorProvider. W nav.component.ts przy login error zamiast stringa przekazujemy po prostu error, ktory skorzysta z interceptora i sam 
stworzy poprawną wiadomość na podstawie info z headera. Jednak kiedy sprobuemy sie zarejestrowac i podajemy zle dane, error w konsoli bedzie wygladal zle. Tworzymy wiec stałą serverErro biorącą zawartość response.error, a nie header,
tworzymy pusty string z modalStateErrors. Jeśli serverError nie będzie nullem i jeśli jest typem object, to uruchamiamy pętlę która do pustego stringa dodaje dany error z pętli. W asp net core 2.2 zmieniono wewnetrzna klase error 
i teraz error zawiera dodatkowe informacje, a same wiadomosci są w serverError.errors. Można dodać jeszcze else if dla starszej wersji, z for(const key in serverError) zamiast erverError.errors
Na samym koncu funkcja robi throwError(modalStateErrors || serverError || "Server error"). Zwróci więc albo nasze sformatowane modelStateErrors, albo jesli te nie beda istniec czyste serverError, albo po prostu napis "Server Error" jeśli 
nie znajdziemy nic.

Alertifyjs - npm install alertifyjs --save, potem w angular.json w scripts dodać ścieżkę do alerfify.min.js, a w styles.css dodać impoty do alertify.min.css i alertify/css/themes/bootstrap.min.css, żeby nasze okna były bootstrapowe. 
Chcemy mieć możliwość dodawania alertów z alertify globalnie, z dowolnego miejsca aplikacji. Tworzymy więc alertify.service która będzie opakowywać kod wywoływania alertify w krótkie ładne metody. Dodajemy declare let alertify: any,
czyli zmienną która będzie umożliwiać korzystanie z "domyślnych" metod, które zaimportowaliśmy w angular.json scripts. Dodać metode confirm(message: string, okCallback: () => any) { alertify.confirm(message, function(e)) 
{if (e) { okCallback(); else {}}}}. Pierwsze to wiadomość w okienku, drugie to funkcja która ma się wywołać przy wybraniu "ok". Gdy ta 
zostanie wywołana wywołujemy metodę alertify o nazwie confirm przekazujac jej wiadomosc i funkcje z parametrem e. e to event który może być dowolnego typu, tutaj jest to clickEvent. function(e) jest pustą funkcją która ma się tylko
przekazać, a potem czekać na zmianę wewnątrz e. Zmianą jest kliknięcie które zmienia e na true albo false. Jesli zmieni sie na true, czyli user kliknie na przycisk "ok" wywołana zostanie funkcja wrzucana do naszej osobistej metody confirm.
Dołozyć jeszcze metode success(message: string) {alertify.success(message)} i error, warning, message działające tak samo. Service jest gotowa, trzeba ją dodać do app.module providers. Teraz uzyjemy service - w nav.component.ts 
dodac w konstuktorze alertify: AlertifyService, a w miejscach gdzie są console.log zamienić na this.alertify.[metoda] odpowiadajace wiadomosci. Podobnie w register.component (w error dać this.alertify.error(error)). Restart serwera, przetestować.

Jwt library - npm install @auth0/angular-jwt@2.0.0. Obecnie sprawdzanie tokenu odbywa sie w nav.component. Chcemy zeby wszedzie mozna bylo sprawdzic token, wiec potrzebujemy uslugi. Mamy juz taką authentication.service, więc dokładamy do niej
pole jwtHelper = new JwtHelperService i importujemy JwtHelperService. Tworzymy metode loggedIn() ktora najpierw pobiera token z dysku, a potem zwraca boolean !this.jwtHelper.isTokenExpired(token). Ta metoda sprawdza czy token istnieje i czy 
jest poprawny, zwraca false tylko jesli wszystko jest ok. My chcemy miec odwrotnie, więc dajemy !. Przechodzimy do nav.component.ts i zmieniami zawartosc metody loggedIn na return this.authService.loggedIn(); Teraz token jest sprawdzany dokładniej.

Zmiana "Welcome User" na "Welcome [nazwa]" - w auth.service tworzymy pole decodedToken: any i w metodzie login zaraz po zapisaniu tokenu wywolujemy znowu this.jwtHelper.decodeToken(user.token). Nazwę użytkownika możemy wyciągnąc z tokenu. W nav.html
przy tekście welcome dodajemy {{authService.decodedToken.unique_name}}. auth_service będzie podkreślone, ale to kwestia tego że jest prywatne. Mimo wszystko po zalogowaniu teraz bedzie pokazywac imie. Jednak to działa tylko przy logowaniu, po 
refreshu to nie bedzie dzialac, bo przypisywanie tokenu do decodedTokem bedzie sie odbywac tylko w metodzie login i unique_name nie bedzie istnieć. Dodając po decodedToken? znak zapytania error w konsoli zniknie, ale dalej nie bedzie pokazywac imienia.
Zostaje jeszcze error przy authService, jest dlatego że w js nie ma podziału na prywatne i publiczne pola (a w ts jest taki podział) i nawet jeśli jest private to html może się do tego odwołać (!). Zamienić authService na public żeby się tego pozbyć.
Z tym że username jest widoczny tylko przy logowaniu można sobie poradzić w prosty sposób, wywołując metodę odczytującą token na samym początku działania strony, czyli w app.component.ts. Ten komponent nie ma jednak onInit, trzeba zrobić class extends
OnInit, dodać konstruktor przyjmujacy authService: AuthService) i metode ngOnInie() która pobierze token i jeśli ten istnieje wywoła authservice.decodedtoken = this.jwtHelper.decodeToken(token). Teraz powinno działac w kazdym wypadku. Na koncu zmienimy 
nazwie pierwsza litere na wielka. W htmlu w {{ | titlecase}} dodajemy titlecase i html zrobi reszte.

Ngx bootstrap i dropdown menu - npm install ngx-bootstrap@3.0.1 --save. Import - w app.module w imports dodajemy sekcje z instrukcji droptown (każdy komponent ma swój import) i import BsDropdownModule. Szukamy dropdown trigger by <a>, wchodzimy w 
nav.html i szukamy klasy dropdown, dodajemy znacznik dropdown, w <a> niżej dodajemy dropdownToggle, a w dropdown-menu dodajemy *dropdownMenu. To znaczniki informujące ngxbootstrap że chcemy mieć w tych miejscach dropdownToggle. Teraz kosmetyka - wrzucamy 
wszystko z nav.html w div class="containter" oprocz 1 i ostatniej linijki żeby zbliżyć wszystko do siebie. Dodajemy do class dropdown-menu mt-3 żeby pojawialo sie troche nizej, wchodzimy w nav.css i robimy .dropdown-toggle, dropdown-item{cursor: pointer}, usuwamy nav-item
logout i dodajemy (click)="logout()" do dropdown-item logout, wczesniejsza wersja byla tymczasowo bo nie mielismy jak dostac sie do przycisku. Dodajemy jeszcze *ngIf("loggedIn()") w navbar-nav mr-auto, żeby nie pokazywac opcji typu matche, wiadomosci 
niezalogowanym userom. 

Bootswatch themes - npm install bootswatch, styles.css, import po bootstrap.min.css - dist/united/bootstrap.min.css. Zmienic w nav.component.html navbar navbar-expand-mds navbar-dark bg-dark ostatnie na bg-primary. Wrzucic na repo.